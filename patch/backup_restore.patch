Index: Application/DSM/DSMLibrary/CliModule.py
===================================================================
--- Application/DSM/DSMLibrary/CliModule.py	(revision 74135)
+++ Application/DSM/DSMLibrary/CliModule.py	(working copy)
@@ -10,16 +10,13 @@
     1. setup_cli_connection
     2. convert_to_failover
     3. convert_to_primary
-
+    4. genca
 """
 
 
-#Standard lib
+# Standard lib
 import time
-import os
 import sys
-import random
-import subprocess
 import pexpect
 
 # Update System path
@@ -27,11 +24,16 @@
 sys.path.insert(0, abspath(
     join(dirname(__file__), '../../../../../test-cases')))
 
-#local lib
+
+# Rest Imports
+from dsm.rest.library import utilitylib as rest_utility_lib
+from dsm.rest.objects.system_object import System
+from dsm.rest.modules import modules as rest_modules
+
+# local lib
 from PageObjectModel.Application.DSM import DsmConstants as dsm_const
 from PageObjectModel.CommonUtilities import ReportLib as RB
 from PageObjectModel.CommonUtilities import CustomException as CE
-from PageObjectModel.CommonUtilities import CustomException as CE
 from PageObjectModel.CommonUtilities import UtilityLib as UtilLib
 
 
@@ -43,21 +45,22 @@
     if not server_name or not user_name or not password:
         raise CE.ArgumentValueNotProvided
 
-    RB.print_info(text="Setting up ssh connection with [%s]" %server_name)
-    RB.print_info(text="Arguments:[%s, %s , %s , %s]" %(server_name, user_name, password, prompt))
+    RB.print_info(text="Setting up ssh connection with [%s]" % server_name)
+    RB.print_info(text="Arguments:[%s, %s , %s , %s]" % (
+        server_name, user_name, password, prompt))
     RB.print_info(text="Deleting public keys")
     UtilLib.delete_public_keys(ip_list=[server_name])
     child = pexpect.spawn(dsm_const.SSH_CMD + user_name + "@" + server_name)
     index = child.expect([dsm_const.RESP1, user_name,
-                         dsm_const.RESP3, "Password.*"])
-    #index = 0 if ssh connection is first time.
-    #index = 1 if ssh connection is already exist.
+                          dsm_const.RESP3, "Password.*"])
+    # index = 0 if ssh connection is first time.
+    # index = 1 if ssh connection is already exist.
     if index == 0:
         child.sendline(dsm_const.SEND_YES)
         child.expect("(P|p)assword")
         child.sendline(password)
         j = child.expect([prompt, dsm_const.CLI_RESP, dsm_const.DENIED,
-                        dsm_const.CLI_PASS_R1, "READ .*", "cli daemon.*"])
+                          dsm_const.CLI_PASS_R1, "READ .*", "cli daemon.*"])
         if j == 0:
             pass
         elif j == 1:
@@ -69,13 +72,14 @@
             child.sendline(dsm_const.CLI_NEW_PASSWORD)
             child.expect(dsm_const.CLI_PASS_R2)
             child.sendline(dsm_const.CLI_NEW_PASSWORD)
-            child.expect(dsm_const.CLI_PASS_SUCCESS, timeout=dsm_const.MAX_TIME)
-           # index = child.expect([ENTER_IPMI_PASS, CLI_RESP], timeout=MAX_TIME)
-           # if index == 0:
-           #     child.sendline(IPMI_NEW_PASS)
-           #     child.expect(RE_ENTER_IPMI_PASS)
-           #     child.sendline(IPMI_NEW_PASS)
-           #     child.expect(CLI_PASS_SUCCESS, timeout=MAX_TIME)
+            child.expect(dsm_const.CLI_PASS_SUCCESS,
+                         timeout=dsm_const.MAX_TIME)
+            # index = child.expect([ENTER_IPMI_PASS, CLI_RESP], timeout=MAX_TIME)
+            # if index == 0:
+            #     child.sendline(IPMI_NEW_PASS)
+            #     child.expect(RE_ENTER_IPMI_PASS)
+            #     child.sendline(IPMI_NEW_PASS)
+            #     child.expect(CLI_PASS_SUCCESS, timeout=MAX_TIME)
 
         elif j == 4:
             child.send("q")
@@ -85,32 +89,34 @@
             child.sendline(dsm_const.CLI_NEW_PASSWORD)
             child.expect(dsm_const.CLI_PASS_R2)
             child.sendline(dsm_const.CLI_NEW_PASSWORD)
-            child.expect(dsm_const.CLI_PASS_SUCCESS, timeout=dsm_const.MAX_TIME)
-           # index = child.expect([ENTER_IPMI_PASS, CLI_RESP], timeout=MAX_TIME)
-           # if index == 0:
-           #     child.sendline(IPMI_NEW_PASS)
-           #     child.expect(RE_ENTER_IPMI_PASS)
-           #     child.sendline(IPMI_NEW_PASS)
-           #     child.expect(CLI_PASS_SUCCESS, timeout=MAX_TIME)
+            child.expect(dsm_const.CLI_PASS_SUCCESS,
+                         timeout=dsm_const.MAX_TIME)
+            # index = child.expect([ENTER_IPMI_PASS, CLI_RESP], timeout=MAX_TIME)
+            # if index == 0:
+            #     child.sendline(IPMI_NEW_PASS)
+            #     child.expect(RE_ENTER_IPMI_PASS)
+            #     child.sendline(IPMI_NEW_PASS)
+            #     child.expect(CLI_PASS_SUCCESS, timeout=MAX_TIME)
         elif j == 5:
             RB.print_err(text="CLI-daemon not yet started.")
             child.close()
-            raise CliDaemonError
+            raise CE.CliDaemonError
     elif index == 1:
         child.sendline(password)
         j = child.expect([dsm_const.CLI_PASS_R1, prompt, dsm_const.CLI_RESP,
-                dsm_const.DENIED, "READ .*", "cli daemon.*"])
+                          dsm_const.DENIED, "READ .*", "cli daemon.*"])
         if j == 0:
             child.sendline(dsm_const.CLI_NEW_PASSWORD)
             child.expect(dsm_const.CLI_PASS_R2)
             child.sendline(dsm_const.CLI_NEW_PASSWORD)
-            child.expect(dsm_const.CLI_PASS_SUCCESS, timeout=dsm_const.MAX_TIME)
-           # index = child.expect([ENTER_IPMI_PASS, CLI_RESP], timeout=MAX_TIME)
-           # if index == 0:
-           #     child.sendline(IPMI_NEW_PASS)
-           #     child.expect(RE_ENTER_IPMI_PASS)
-           #     child.sendline(IPMI_NEW_PASS)
-           #     child.expect(CLI_PASS_SUCCESS, timeout=MAX_TIME)
+            child.expect(dsm_const.CLI_PASS_SUCCESS,
+                         timeout=dsm_const.MAX_TIME)
+            # index = child.expect([ENTER_IPMI_PASS, CLI_RESP], timeout=MAX_TIME)
+            # if index == 0:
+            #     child.sendline(IPMI_NEW_PASS)
+            #     child.expect(RE_ENTER_IPMI_PASS)
+            #     child.sendline(IPMI_NEW_PASS)
+            #     child.expect(CLI_PASS_SUCCESS, timeout=MAX_TIME)
         elif j == 4:
             child.send("q")
             child.expect("Do you accept .*")
@@ -119,18 +125,19 @@
             child.sendline(dsm_const.CLI_NEW_PASSWORD)
             child.expect(dsm_const.CLI_PASS_R2)
             child.sendline(dsm_const.CLI_NEW_PASSWORD)
-            child.expect(dsm_const.CLI_PASS_SUCCESS, timeout=dsm_const.MAX_TIME)
-           # index = child.expect([ENTER_IPMI_PASS, CLI_RESP], timeout=MAX_TIME)
-           # if index == 0:
-           #     child.sendline(IPMI_NEW_PASS)
-           #     child.expect(RE_ENTER_IPMI_PASS)
-           #     child.sendline(IPMI_NEW_PASS)
-           #     child.expect(CLI_PASS_SUCCESS, timeout=MAX_TIME)
+            child.expect(dsm_const.CLI_PASS_SUCCESS,
+                         timeout=dsm_const.MAX_TIME)
+            # index = child.expect([ENTER_IPMI_PASS, CLI_RESP], timeout=MAX_TIME)
+            # if index == 0:
+            #     child.sendline(IPMI_NEW_PASS)
+            #     child.expect(RE_ENTER_IPMI_PASS)
+            #     child.sendline(IPMI_NEW_PASS)
+            #     child.expect(CLI_PASS_SUCCESS, timeout=MAX_TIME)
         elif j == 1 or j == 2:
             pass
         elif j == 3:
             RB.print_err(text="Please enter the correct password.")
-            raise AuthError
+            raise CE.AuthError
         elif j == 5:
             RB.print_err(text="CLI-daemon not yet started.")
             child.close()
@@ -139,7 +146,7 @@
 
 
 def convert_to_failover(primary_server='', failover_server='',
-                        primary_admin_name='' , primary_admin_pass=''):
+                        primary_admin_name='', primary_admin_pass=''):
     """Convert primary to failover server
 
     Args:
@@ -150,15 +157,15 @@
     """
 
     if not primary_server or not failover_server or\
-        not primary_admin_name or not primary_admin_pass :
+            not primary_admin_name or not primary_admin_pass:
         raise CE.ArgumentValueNotProvided
 
     # Spawning the ssh to server
     prompt = "0.*"
     child = setup_cli_connection(server_name=failover_server,
-                                user_name=dsm_const.CLI_USERNAME,
-                                password=dsm_const.CLI_NEW_PASSWORD,
-                                prompt=prompt)
+                                 user_name=dsm_const.CLI_USERNAME,
+                                 password=dsm_const.CLI_NEW_PASSWORD,
+                                 prompt=prompt)
     child.logfile = sys.stdout
 
     try:
@@ -189,23 +196,25 @@
         child.expect(dsm_const.HA_CONTINUE, timeout=dsm_const.MAX_TIME)
         child.sendline(dsm_const.SEND_YES)
         retval = child.expect([dsm_const.SUCCESS_RESP, dsm_const.ERROR_RESP],
-                timeout = dsm_const.MAX_TIME,
-                searchwindowsize = dsm_const.SEARCHWINSIZE)
+                              timeout=dsm_const.MAX_TIME,
+                              searchwindowsize=dsm_const.SEARCHWINSIZE)
         if retval:
-            RB.print_err(text="Convert to failover failed on server [%s]" %failover_server)
+            RB.print_err(
+                text="Convert to failover failed on server [%s]" % failover_server)
             child.close()
             return False
 
-        child.sendline(dsm_const.EXIT_CMD) #sending Exit status.
+        child.sendline(dsm_const.EXIT_CMD)  # sending Exit status.
     except pexpect.TIMEOUT:
-        RB.print_err(text="Timeout while converting server[%s] to failover." %failover_server)
+        RB.print_err(
+            text="Timeout while converting server[%s] to failover." % failover_server)
         child.close()
         return False
     child.close()
     return True
 
+
 def convert_to_primary(server=''):
-
     """Convert primary to failover server
 
        Args:
@@ -219,8 +228,8 @@
     # Spawning the ssh to server
     prompt = "0.*"
     child = setup_cli_connection(server_name=server, user_name=dsm_const.CLI_USERNAME,
-                                password=dsm_const.CLI_NEW_PASSWORD,
-                                prompt=prompt)
+                                 password=dsm_const.CLI_NEW_PASSWORD,
+                                 prompt=prompt)
     child.logfile = sys.stdout
     try:
         # Expect the normal procedure of convert to primary
@@ -229,7 +238,8 @@
         child.sendline(dsm_const.HA_3)
         child.expect(dsm_const.HA_3_RESP, timeout=dsm_const.MAX_TIME)
         child.sendline(dsm_const.SEND_YES)
-        i = child.expect([dsm_const.SUCCESS_RESP, dsm_const.ERROR_RESP], timeout=dsm_const.MAX_TIME, \
+        i = child.expect([dsm_const.SUCCESS_RESP, dsm_const.ERROR_RESP],
+                         timeout=dsm_const.MAX_TIME,
                          searchwindowsize=dsm_const.SEARCHWINSIZE)
         child.sendline(dsm_const.EXIT_CMD)
         if i == 1:
@@ -237,9 +247,47 @@
             return False
 
     except pexpect.TIMEOUT:
-        RB.print_err(text="Timeout while converting server [%s] to Primary." \
-            % server)
+        RB.print_err(text="Timeout while converting server [%s] to Primary."
+                     % server)
         child.close()
         return False
     child.close()
     return True
+
+
+def genca(dsm_url=dsm_const.DSM_URL, dsm_host_name=dsm_const.DSM_HOSTNAME):
+    RB.print_info("Performing security genca.")
+
+    system_api = System(dsm_url=dsm_url,
+                        dsm_username=dsm_const.DSM_USERNAME,
+                        dsm_password=dsm_const.DSM_PASSWORD)
+    # Perform security genca
+    configure_dict = {
+        "certificateAuthorityConfig": {
+            "hostName": dsm_host_name,
+            "organizationUnit": dsm_const.ORG_UNIT,
+            "organization": dsm_const.ORG_NAME,
+            "city": dsm_const.CITY_NAME,
+            "state": dsm_const.STATE_NAME,
+            "country": dsm_const.COUNTRY_CODE
+        }
+    }
+
+    try:
+        rest_modules.configure_system(
+            system_api=system_api,
+            option='ca',
+            configure_dict=configure_dict)
+    except Exception:
+        pass
+
+    # Wait for DSM to go down
+    time.sleep(dsm_const.GENERAL_WAIT_TIME)
+
+    result = rest_utility_lib.wait_for_dsm_to_come_up(
+        ip_address=dsm_const.DSM_HOSTNAME,
+        max_time=dsm_const.MAX_TIME,
+        interval=dsm_const.GENERAL_WAIT_TIME)
+
+    if not result:
+        sys.exit(1)
Index: Application/DSM/DSMLibrary/DsmModule.py
===================================================================
--- Application/DSM/DSMLibrary/DsmModule.py	(revision 74135)
+++ Application/DSM/DSMLibrary/DsmModule.py	(working copy)
@@ -2,32 +2,30 @@
 
 """
 .. module:: DSM Module
-"""
+DSM Module
 
-"""DSM Module
-
 This module contains DSM related methods:
     1. get_dsm_upgrade_file
+    2. get_backup_file_path
 """
 
 
-#Standard lib
-import time
+# Standard lib
 import os
 import sys
 
+
 # Update System path
 from os.path import abspath, dirname, join
 sys.path.insert(0, abspath(
     join(dirname(__file__), '../../../../../test-cases')))
 
-#local lib
+# local lib
 from PageObjectModel.Application.DSM import DsmConstants as dsm_const
 from PageObjectModel.CommonUtilities import ReportLib as RB
 from PageObjectModel.CommonUtilities import CustomException as CE
+from PageObjectModel.CommonUtilities import UtilityLib as UL
 
-#pom dsm constant
-from PageObjectModel.Application.DSM import DsmConstants as dsm_const
 
 def get_dsm_upgrade_file(build_id='', build_path_dir=''):
     """ Get DSM upgrade tar file from nfs server
@@ -39,12 +37,61 @@
     """
     try:
         if not build_id and not build_path_dir:
-             raise CE.ArgumentValueNotProvided
-        build_path = os.path.join(build_path_dir, dsm_const.local_nfs_build_path + build_id)
-        upgrade_file = dsm_const.upgrade_pattern %build_id
+            raise CE.ArgumentValueNotProvided
+        build_path = os.path.join(
+            build_path_dir, dsm_const.local_nfs_build_path + build_id)
+        upgrade_file = dsm_const.upgrade_pattern % build_id
         upgrade_file_path = os.path.join(build_path, upgrade_file)
-        RB.print_info(text="Upgrade file : %s \n" %upgrade_file_path)
+        if not upgrade_file_path:
+            RB.print_info(text="Unable to get the upgrade file.")
+            return None
+
+        RB.print_info(text="Upgrade file : %s \n" % upgrade_file_path)
         return upgrade_file_path
-    except Exception as error:
+    except Exception:
         return None
 
+
+def get_backup_file_path(file_info_dict={}, mount_dir_path=''):
+    """
+    This function gets the file_info_dict create one string pattern from that,
+       search that pattern in given dir_path and returns file of given file type.
+
+    file_info_dict = {
+                       "build_number":'6.0.3',
+                       "build_version":'5098',
+                       "file_type":'.tar'
+                      }
+    Retruns:
+       backup file path or None
+
+    """
+    try:
+        build_number = str(file_info_dict['build_number'])
+        backup_path = dsm_const.NON_KMIP_BACKUP_FILE_PATH[build_number[0]]
+        backup_path += "*" + file_info_dict['file_type']
+    except KeyError:
+        RB.print_err(
+            text='build path is not there is dsm constants for DSM [%s]' % (
+                file_info_dict['build_number']))
+    try:
+        build_version = str(file_info_dict['build_version'])
+        if not build_version:
+            raise KeyError
+    except KeyError:
+        build_version = '\d{4}'
+
+    patern = build_number +\
+        "." + build_version +\
+        "[_?]" + "[^\d.\d.\d.\d{3}]"
+
+    file_path = mount_dir_path + backup_path
+
+    absolute_file_path = UL.get_file_from_local_machine(dir_path=file_path,
+                                                        file_patern=patern)
+
+    if not absolute_file_path:
+        RB.print_err(text='Unable to get desired file from given arguments.')
+        return None
+    else:
+        return absolute_file_path[0]
Index: Application/DSM/DSMLocators/DefaultLocators.yaml
===================================================================
--- Application/DSM/DSMLocators/DefaultLocators.yaml	(revision 74135)
+++ Application/DSM/DSMLocators/DefaultLocators.yaml	(working copy)
@@ -92,6 +92,8 @@
  xpath : //label[text()='Confirm New Password']/../..//input
 
 #BasePage Locators
+loading_icon:
+ xpath : //div[@class='wicket-mask']
 
 wicket_div:
  xpath: //div[@class='wicket-veil']
@@ -2329,6 +2331,9 @@
 policies_add_policy_key_selection_rules_select_keyname:
  xpath: //table[@class='dataview']//span[text()='%s']/../../../..//input
 
+policies_add_policy_key_selection_rules_search_box_keyname:
+ xpath: //label[text()='Name Contains']/../..//input
+
 policies_add_policy_key_selection_rules_select_key_btn:
  xpath: //input[@value='Select Key']
 
@@ -4794,7 +4799,7 @@
 
 system_backup_restore_restore_import_cfg_file_label:
  xpath : //label[text()='Import Configuration File']
-system_backup_restore_restore_import_cfg_file_file:
+system_backup_restore_restore_import_cfg_file:
  xpath : //input[@type='file']
 
 system_backup_restore_restore_inclde_usrs_label:
Index: Application/DSM/DSMPages/BackupRestore.py
===================================================================
--- Application/DSM/DSMPages/BackupRestore.py	(revision 0)
+++ Application/DSM/DSMPages/BackupRestore.py	(working copy)
@@ -0,0 +1,242 @@
+# !/usr/bin/python
+
+######################################################################
+# """                                                                #
+# .. module:: backup_restore_page_object                             #
+# """                                                                #
+#                                                                    #
+# Defines wrappers over backup restore page specific actions.        #
+# Performs verification wherever necessary and possible.             #
+######################################################################
+
+# Standard python library
+import time
+import sys
+from os.path import abspath, dirname, join
+
+# Update path
+sys.path.insert(0, abspath(
+    join(dirname(__file__), '../../../../../test-cases')))
+
+
+# Rest Imports
+from dsm.rest.modules import modules as rest_modules
+from dsm.rest.objects.backup_object import Backup
+from dsm.rest.objects.restore_object import Restore
+
+
+# Framework library modules
+from PageObjectModel.Application.DSM import DsmConstants as dsm_const
+from PageObjectModel.CommonUtilities import UtilityLib as UtilLib
+from PageObjectModel.Application.DSM.DSMPages.BasePage import BasePage
+from PageObjectModel.CommonUtilities import ReportLib as RB
+from PageObjectModel.CommonUtilities import CustomException as CE
+
+from PageObjectModel.ExternalToolLib.ElementryFunctions import ElementryFunctions as EF
+
+
+class BackupRestorePage(BasePage):
+    """
+    backup_restore_page class provides all the functions
+    specific to backup restore page and also inherits the base page.
+    """
+
+    def __init__(self, driver="",
+                 dsm_url=dsm_const.DSM_URL,
+                 dsm_username=dsm_const.DSM_USERNAME,
+                 dsm_password=dsm_const.DSM_PASSWORD,
+                 version=""):
+        """
+        Create an instance of page interface
+        Args:
+            driver: instance of selenium webdriver
+            dsm_url: DSM URL(Secure HTTP + IP Addr + Port + RESTful API vers)
+            dsm_username: Username
+            dsm_password: Password
+        """
+        self.driver = driver
+        super(BackupRestorePage, self).__init__(
+            driver=self.driver, version=version)
+        self.EF = EF(self.driver)
+
+    # Method def go_to_system_wrapper_keys_page() is defined in base_page
+    # Method def go_to_system_backup_restore_page() is defined in base_page
+    # Method def go_to_system_backup_restore_auto_backup_page() is defined in base_page
+    def manual_backup(self,
+                      server_dict={},
+                      by_method=dsm_const.GLOBAL_BY_METHOD,
+                      user_name=dsm_const.DSM_USERNAME,
+                      password=dsm_const.DSM_PASSWORD,
+                      print_info_flag=False,
+                      print_exception=True,
+                      validate_flag=True):
+        """Create manual backup using given arguments.
+        EP:
+          BackupRestore / manual backup
+
+        Args:
+            server_dict = {
+                          download_dir: path of downloaded file,
+                          server: SELENIUM SERVER INFO,
+                          user_name: SERVER USERNAME
+                          password:  SERVER PASSWROD
+                          }
+            by_method : gui/ rest/ vmssc
+            user_name : username of system admin
+            password : password for the system admin
+            print_info_flag : print the base operations or not
+            print_exception : print the exceptions in base methor or not.
+            validate_flag : validate the operation.
+        """
+        if not server_dict:
+            RB.print_err(
+                text='SERVER DICT is not provided to get the backup file')
+            raise CE.ArgumentValueNotProvided
+
+        RB.print_info(text="Taking manual backup by [%s]" % (by_method))
+
+        if by_method.lower() == "rest":
+
+            backup_api = Backup(dsm_url=dsm_const.DSM_URL,
+                                dsm_username=user_name,
+                                dsm_password=password)
+
+            # This function returns binary data, create a file and write the data into it.
+            data = rest_modules.get_manual_backup(backup_api=backup_api)
+
+            return data
+        else:
+
+            self.go_to_system_backup_restore_page()
+            try:
+                msg = self.EF.read_text(
+                    locator=self.locator_dict['feedback_panel_info'],
+                    print_exception=False)
+            except CE.ElementNotFound:
+                msg = self.EF.read_text(
+                    locator=self.locator_dict['feedback_panel'],
+                    print_exception=False)
+                RB.print_err(text=str(msg))
+                return False
+            self.EF.element_click(
+                locator=self.locator_dict['ok_btn'],
+                print_exception=print_exception,
+                print_info_flag=print_info_flag)
+
+            for _ in range(10):
+                try:
+                    time.sleep(7)
+                    self.EF.wait_for_element(
+                        locator=self.locator_dict['loading_icon'], print_exception=False)
+                except CE.ElementNotFound:
+                    break
+            """remove previosly downloaded files from server"""
+            if UtilLib.remove_files_from_server(file_path=server_dict['download_dir'],
+                                                server=server_dict['server'],
+                                                user_name=server_dict['user_name'],
+                                                password=server_dict['password']):
+                RB.print_info(
+                    text="Previously downloaded files are removed from server.")
+            else:
+                RB.print_warn(
+                    text="Failed to delete previously downloaded files from server.")
+
+            """get latest downladed backup file from server"""
+            backup_file = UtilLib.get_latest_downloaded_filepath_from_server(
+                download_dir=server_dict['download_dir'],
+                server=server_dict['server'],
+                user_name=server_dict['user_name'],
+                password=server_dict['password'])
+
+            if validate_flag:
+                if not backup_file:
+                    if print_info_flag:
+                        RB.print_err(text="Backup file is not created.")
+                    raise CE.ValidateError("Manual Backup Failed.")
+
+            return join(server_dict['download_dir'], backup_file)
+
+    def restore_backup_file(self,
+                            backup_file_path="",
+                            include_users=False,
+                            dsm_host_name=dsm_const.DSM_HOSTNAME,
+                            by_method=dsm_const.GLOBAL_BY_METHOD,
+                            user_name=dsm_const.DSM_USERNAME,
+                            password=dsm_const.DSM_PASSWORD,
+                            print_info_flag=False,
+                            print_exception=True,
+                            validate_flag=True):
+        """Create manual backup using given arguments.
+        EP:
+          BackupRestore / manual backup
+
+        Args:
+            by_method : gui/ rest/ vmssc
+            user_name : username of system admin
+            password : password for the system admin
+            print_info_flag : print the base operations or not
+            print_exception : print the exceptions in base methor or not.
+            validate_flag : validate the operation.
+        """
+
+        RB.print_info(text="Restoring backup by [%s]" % (by_method))
+        if not backup_file_path:
+            RB.print_err(text="Backup file is not provided to restore.")
+            raise CE.ArgumentValueNotProvided
+
+        if by_method.lower() == "rest":
+
+            restore_api = Restore(dsm_url=dsm_const.DSM_URL,
+                                  dsm_username=user_name,
+                                  dsm_password=password)
+
+            # This function returns binary data, create a file and write the data into it.
+            rest_modules.restore_backup(
+                restore_api=restore_api, backup_file=backup_file_path)
+
+        else:
+            self.go_to_system_backup_restore_page()
+            self.EF.element_click(
+                locator=self.locator_dict['system_backup_restore_restore_tab'],
+                print_exception=print_exception,
+                print_info_flag=print_info_flag)
+            try:
+                msg = self.EF.read_text(
+                    locator=self.locator_dict['feedback_panel_warn'],
+                    print_exception=False)
+                if 'Please create/import wrapper key for Backup/Restore' in msg:
+                    RB.print_err(text=msg)
+                    return False
+            except CE.ElementNotFound:
+                pass
+            self.EF.send_keys(
+                data=backup_file_path,
+                locator=self.locator_dict[
+                    'system_backup_restore_restore_import_cfg_file'])
+
+            if include_users:
+                self.EF.element_click(
+                    locatpr=self.locator_dict[
+                        'system_backup_restore_restore_inclde_usrs_cb'],
+                    print_exception=print_exception,
+                    print_info_flag=print_info_flag)
+
+            self.EF.element_click(
+                locator=self.locator_dict['ok_btn'],
+                print_exception=print_exception,
+                print_info_flag=print_info_flag)
+            self.EF.handle_alert(accept=True)
+
+            try:
+                err_msg = self.EF.read_text(
+                    locator=self.locator_dict['feedback_panel_error'])
+
+                RB.print_err(text=err_msg)
+                return None
+
+            except CE.ElementNotFound:
+                pass
+
+            if validate_flag:
+                return self.wait_for_login_page(
+                    dsm_host_name=dsm_host_name)
Index: Application/DSM/DSMPages/BasePage.py
===================================================================
--- Application/DSM/DSMPages/BasePage.py	(revision 74135)
+++ Application/DSM/DSMPages/BasePage.py	(working copy)
@@ -759,8 +759,8 @@
                      by_locator_type,
                      locator) = self.EF.wait_for_element(
                          locator=self.locator_dict['logged_in_domain_label'],
-                         print_exception=print_exception)
-                except Exception:
+                         print_exception=False)
+                except CE.ElementNotFound:
                     pass
 
                 if element is not None:
@@ -802,6 +802,23 @@
         index_of_colon = index_of_colon + 1
         return int(total_count[index_of_colon:])
 
+    def wait_for_login_page(self, dsm_host_name=dsm_const.DSM_HOSTNAME):
+        for retry in range(100):
+            try:
+                time.sleep(15)
+                self.go_to_login_page(dsm_host_name)
+                self.EF.wait_for_element(
+                    locator=self.locator_dict['login_username_txt'],
+                    print_exception=False)
+                if retry:
+                    return True
+                else:
+                    return False
+            except CE.ElementNotFound:
+                pass
+        else:
+            return False
 
+
 if __name__ == "__main__":
     BasePage()
Index: Application/DSM/DSMPages/HostPage.py
===================================================================
--- Application/DSM/DSMPages/HostPage.py	(revision 74135)
+++ Application/DSM/DSMPages/HostPage.py	(working copy)
@@ -30,15 +30,16 @@
 from PageObjectModel.ExternalToolLib.ElementryFunctions import ElementryFunctions as EF
 from PageObjectModel.WebDriverUtility.GetWebDriver import GetWebDriver
 
-#rest modules
+# rest modules
 from dsm.rest.library import agentlib
 from dsm.rest.modules import core_modules as rest_core_modules
 from dsm.rest.modules import modules as rest_modules
 from dsm.rest.objects.host_object import Host
 from dsm.rest.objects.host_group_object import HostGroup
-#dsm constant
+# dsm constant
 from dsm import constants as const
 
+
 class HostPage(BasePage):
 
     def __init__(self,
@@ -434,11 +435,12 @@
                 locator=self.locator_dict['host_hostname_cb_in_table'],
                 value_tuple=(host_name), print_exception=print_exception)
             if element:
-                RB.print_debug(text="Host [%s] found on host page" %host_name)
+                RB.print_debug(text="Host [%s] found on host page" % host_name)
                 return True
         except Exception as _e:
-            #RB.print_err(text=_e)
-            RB.print_debug(text="Host [%s] not found on host page.\n" %host_name)
+            # RB.print_err(text=_e)
+            RB.print_debug(
+                text="Host [%s] not found on host page.\n" % host_name)
             return False
 
     def add_host(self,
@@ -465,7 +467,7 @@
             install_register_flag : if True will install and register the host as well
             validate : Flag to validate if host is added
         """
-        RB.print_info(text="Adding host [%s].\n" %host_dict['name'])
+        RB.print_info(text="Adding host [%s].\n" % host_dict['name'])
         if host_dict is {}:
             raise self.CE.ArgumentValueNotProvided
 
@@ -476,59 +478,60 @@
         else:
             self.go_to_host_page()
             self.EF.element_click(
-                    locator=self.locator_dict['add_btn'])
-            #default host form fields dict
+                locator=self.locator_dict['add_btn'])
+            # default host form fields dict
             default_host_dict = {
-                    "name" : self.locator_dict['host_add_host_hostname_txt'],
-                    "desc" : self.locator_dict['host_add_host_description_txt'],
-                    "license_type" : self.locator_dict['host_add_host_license_type_ddl'],
-                    "VTE": self.locator_dict['host_add_fs_agent_cb'],
-                    "Key": self.locator_dict['host_add_key_agent_cb'],
-                    "VDE": self.locator_dict['host_add_vde_agent_cb'],
-                    "KMIP": self.locator_dict['host_add_kmip_agent_cb'],
-                    "enabled" : self.locator_dict['host_add_host_comm_enabled_cb'],
-                    }
-            #form list
+                "name": self.locator_dict['host_add_host_hostname_txt'],
+                "desc": self.locator_dict['host_add_host_description_txt'],
+                "license_type": self.locator_dict['host_add_host_license_type_ddl'],
+                "VTE": self.locator_dict['host_add_fs_agent_cb'],
+                "Key": self.locator_dict['host_add_key_agent_cb'],
+                "VDE": self.locator_dict['host_add_vde_agent_cb'],
+                "KMIP": self.locator_dict['host_add_kmip_agent_cb'],
+                "enabled": self.locator_dict['host_add_host_comm_enabled_cb'],
+            }
+            # form list
             form_list = []
             for key in host_dict:
                 try:
                     form_list.append({'locator': default_host_dict[key],
-                               'value': host_dict[key]})
+                                      'value': host_dict[key]})
                 except KeyError:
                     pass
             form_list.append({'locator': self.locator_dict['ok_btn'],
-                          'value': 'button'})
+                              'value': 'button'})
             self.EF.fill_form(form_list=form_list,
-                  print_info_flag=print_info_flag,
-                  print_exception=print_exception)
+                              print_info_flag=print_info_flag,
+                              print_exception=print_exception)
 
         if validate_flag:
             try:
                 self.search_host(host_dict['name'])
-            except Exception as _e:
+            except Exception:
                 raise CE.ValidateError
         if install_register_flag:
             result = agentlib.install_agent(const.AGENT_HOSTNAME,
-                                          const.AGENT_USERNAME,
-                                          const.AGENT_PASSWORD,
-                                          const.AGENT_BUILD_VERSION,
-                                          const.AGENT_BUILD_NUMBER,
-                                          const.DSM_HOSTNAME,
-                                          user_name,
-                                          password,
-                                          domain_name)
+                                            const.AGENT_USERNAME,
+                                            const.AGENT_PASSWORD,
+                                            const.AGENT_BUILD_VERSION,
+                                            const.AGENT_BUILD_NUMBER,
+                                            const.DSM_HOSTNAME,
+                                            user_name,
+                                            password,
+                                            domain_name)
             if result:
-                RB.print_info(text="Agent installation and registration successful.\n")
+                RB.print_info(
+                    text="Agent installation and registration successful.\n")
             else:
-                RB.print_err(text="Agent installation and registration failed.\n")
-                raise
+                RB.print_err(
+                    text="Agent installation and registration failed.\n")
 
-    def total_host_count(self, domain_name = '',
-                                by_method=dsm_const.GLOBAL_BY_METHOD,
-                                 user_name=dsm_const.DSM_USERNAME,
-                                 password=dsm_const.DSM_PASSWORD,
-                                 print_info_flag=False,
-                                 print_exception=True):
+    def total_host_count(self, domain_name='',
+                         by_method=dsm_const.GLOBAL_BY_METHOD,
+                         user_name=dsm_const.DSM_USERNAME,
+                         password=dsm_const.DSM_PASSWORD,
+                         print_info_flag=False,
+                         print_exception=True):
         """This gives total count for hosts on DSM
         EP:
             HostPage / get total host count
@@ -549,14 +552,14 @@
             return self.retrieve_total_count_in_table()
 
     def add_guardpoint_to_host(self,
-                 guardpoint_dict="",
-                 domain_name="",
-                 by_method=dsm_const.GLOBAL_BY_METHOD,
-                 user_name=dsm_const.DSM_USERNAME,
-                 password=dsm_const.DSM_PASSWORD,
-                 print_info_flag=False,
-                 print_exception=True,
-                 validate_flag=True):
+                               guardpoint_dict="",
+                               domain_name="",
+                               by_method=dsm_const.GLOBAL_BY_METHOD,
+                               user_name=dsm_const.DSM_USERNAME,
+                               password=dsm_const.DSM_PASSWORD,
+                               print_info_flag=False,
+                               print_exception=True,
+                               validate_flag=True):
         """Edit host -> add guard point
         EP:
           HostPage / Add guardpoint(s) to host
@@ -578,20 +581,22 @@
 
         else:
             if not self.search_host(host_name=guardpoint_dict['host_name']):
-                    return False
+                return False
             self.EF.element_click(
-                    locator=self.locator_dict['host_hostname_in_table'],
-                    value_tuple=(guardpoint_dict['host_name']), print_exception=print_exception)
-            self.EF.element_click(locator=self.locator_dict['host_edit_guardpoint_tab'])
+                locator=self.locator_dict['host_hostname_in_table'],
+                value_tuple=(guardpoint_dict['host_name']),
+                print_exception=print_exception)
             self.EF.element_click(
-                                locator=self.locator_dict['guard_btn'])
-            #default guardpoint form fields dict
+                locator=self.locator_dict['host_edit_guardpoint_tab'])
+            self.EF.element_click(
+                locator=self.locator_dict['guard_btn'])
+            # default guardpoint form fields dict
             default_guardpoint_dict = {
-                    "policy" : self.locator_dict['select_guardpoint_policy'],
-                    "type" : self.locator_dict['select_guardpoint_type'],
-                    "path" : self.locator_dict['guardpoint_path_textarea'],
-                    }
-            #form list
+                "policy": self.locator_dict['select_guardpoint_policy'],
+                "type": self.locator_dict['select_guardpoint_type'],
+                "path": self.locator_dict['guardpoint_path_textarea'],
+            }
+            # form list
             form_list = []
             for key in guardpoint_dict:
                 try:
@@ -599,29 +604,30 @@
                                       'value': guardpoint_dict[key]})
                 except KeyError:
                     pass
-            form_list.append({'locator': self.locator_dict['ok_btn'],
-                          'value': 'button'})
+            # form_list.append({'locator': self.locator_dict['ok_btn'],
+            #               'value': 'button'})
             self.EF.fill_form(form_list=form_list,
-                  print_info_flag=print_info_flag,
-                  print_exception=print_exception)
+                              print_info_flag=print_info_flag,
+                              print_exception=print_exception)
+            self.EF.element_click(locator=self.locator_dict['ok_btn'])
 
         if validate_flag:
             try:
-                self.EF.wait_for_element(locator=self.locator_dict['host_edit_guardpoint_protected_path'],
+                self.EF.wait_for_element(
+                    locator=self.locator_dict['host_edit_guardpoint_protected_path'],
                     value_tuple=(guardpoint_dict['path']), print_exception=False)
             except CE.ElementNotFound:
                 raise CE.ValidateError
 
     def check_guardpoint_status(self,
-                 host_name="",
-                 guard_path="",
-                 domain_name="",
-                 by_method=dsm_const.GLOBAL_BY_METHOD,
-                 user_name=dsm_const.DSM_USERNAME,
-                 password=dsm_const.DSM_PASSWORD,
-                 print_info_flag=False,
-                 print_exception=False):
-
+                                host_name="",
+                                guard_path="",
+                                domain_name="",
+                                by_method=dsm_const.GLOBAL_BY_METHOD,
+                                user_name=dsm_const.DSM_USERNAME,
+                                password=dsm_const.DSM_PASSWORD,
+                                print_info_flag=False,
+                                print_exception=False):
         """Check guard point status
         EP:
           HostPage / check guard point status
@@ -636,7 +642,7 @@
             install_register_flag : if True will install and register the host as well
             validate : Flag to validate if host is added
         """
-        RB.print_info(text="Checking guardpoint status[%s]." %guard_path)
+        RB.print_info(text="Checking guardpoint status[%s]." % guard_path)
         if not host_name:
             raise self.CE.ArgumentValueNotProvided
 
@@ -645,37 +651,40 @@
 
         else:
             if not self.search_host(host_name=host_name):
-                    return False
+                return False
             self.EF.element_click(
-                    locator=self.locator_dict['host_hostname_in_table'],
-                    value_tuple=(host_name), print_exception=print_exception)
-            self.EF.element_click(locator=self.locator_dict['host_edit_guardpoint_tab'])
-            #refresh guardpoint status
+                locator=self.locator_dict['host_hostname_in_table'],
+                value_tuple=(host_name), print_exception=print_exception)
+            self.EF.element_click(
+                locator=self.locator_dict['host_edit_guardpoint_tab'])
+            # refresh guardpoint status
             for i in range(5):
                 try:
                     if self.EF.wait_for_element(locator=self.locator_dict['host_edit_guardpoint_success_status'],
-                                                    timeout=10, poll_freq=5,
-                                                    value_tuple=(guard_path),
-                                                    print_exception=print_exception)[0]:
+                                                timeout=10, poll_freq=5,
+                                                value_tuple=(guard_path),
+                                                print_exception=print_exception)[0]:
                         break
                 except:
-                    self.EF.element_click(locator=self.locator_dict['refresh_btn'])
+                    self.EF.element_click(
+                        locator=self.locator_dict['refresh_btn'])
 
             try:
                 self.EF.element_click(locator=self.locator_dict['host_edit_guardpoint_success_status'],
                                       value_tuple=(guard_path))
-                status_text = self.EF.read_text(locator=self.locator_dict['host_edit_guardpoint_status_success_text'])
+                status_text = self.EF.read_text(
+                    locator=self.locator_dict['host_edit_guardpoint_status_success_text'])
                 if not status_text == 'Guarded':
                     return False
-                self.EF.element_click(locator=self.locator_dict['host_edit_guardpoint_status_window_close'])
+                self.EF.element_click(
+                    locator=self.locator_dict['host_edit_guardpoint_status_window_close'])
                 return True
             except Exception as error:
                 RB.print_err(text=error)
-                RB.print_err(text="Failed to check guardpoint[%s] status.\n" %guard_path)
+                RB.print_err(
+                    text="Failed to check guardpoint[%s] status.\n" % guard_path)
                 return False
 
-
-
     def delete_host(self,
                     host_list=[],
                     domain_name="",
@@ -704,11 +713,12 @@
             if not domain_name:
                 raise CE.ArgumentValueNotProvided
             domain_id = rest_core_modules.get_domain_id(
-                            domain=domain_name)
+                domain=domain_name)
             host_api = Host(dsm_url=dsm_const.DSM_URL, dsm_username=user_name,
                             dsm_password=password, domain_id=domain_id)
             for host_name in host_list:
-                host_id = rest_core_modules.get_host_id(user_name, domain_id, host_name)
+                host_id = rest_core_modules.get_host_id(
+                    user_name, domain_id, host_name)
                 rest_modules.delete_host(host_api, host_id, force=True)
 
         else:
@@ -729,14 +739,14 @@
                         pass
 
     def add_hostgroup(self,
-                 host_group_dict={},
-                 domain_name="",
-                 by_method=dsm_const.GLOBAL_BY_METHOD,
-                 user_name=dsm_const.DSM_USERNAME,
-                 password=dsm_const.DSM_PASSWORD,
-                 print_info_flag=False,
-                 print_exception=True,
-                 validate_flag=True):
+                      host_group_dict={},
+                      domain_name="",
+                      by_method=dsm_const.GLOBAL_BY_METHOD,
+                      user_name=dsm_const.DSM_USERNAME,
+                      password=dsm_const.DSM_PASSWORD,
+                      print_info_flag=False,
+                      print_exception=True,
+                      validate_flag=True):
         """Add host group into a domain
         EP:
           HostPage / add host group
@@ -761,14 +771,14 @@
         else:
             self.go_to_host_groups_page()
             self.EF.element_click(
-                    locator=self.locator_dict['add_btn'])
-            #default host group form fields dict
+                locator=self.locator_dict['add_btn'])
+            # default host group form fields dict
             default_host_group_dict = {
-                    "name" : self.locator_dict['host_host_group_add_host_group_host_group_name_input'],
-                    "cluster_type" : self.locator_dict['host_host_group_add_host_group_cluster_type_input'],
-                    "desc" : self.locator_dict['host_host_group_add_host_group_description_input'],
-                    }
-            #form list
+                "name": self.locator_dict['host_host_group_add_host_group_host_group_name_input'],
+                "cluster_type": self.locator_dict['host_host_group_add_host_group_cluster_type_input'],
+                "desc": self.locator_dict['host_host_group_add_host_group_description_input'],
+            }
+            # form list
             form_list = []
             for key in host_group_dict:
                 try:
@@ -777,29 +787,28 @@
                 except KeyError:
                     pass
             form_list.append({'locator': self.locator_dict['ok_btn'],
-                          'value': 'button'})
+                              'value': 'button'})
             self.EF.fill_form(form_list=form_list,
-                  print_info_flag=print_info_flag,
-                  print_exception=print_exception)
+                              print_info_flag=print_info_flag,
+                              print_exception=print_exception)
 
         if validate_flag:
             try:
                 self.EF.wait_for_element(locator=self.locator_dict['host_group_name_in_table'],
-                    value_tuple=(host_group_dict['name']), print_exception=False)
+                                         value_tuple=(host_group_dict['name']), print_exception=False)
             except Exception as _e:
                 raise CE.ValidateError
 
-
     def add_host_to_hostgroup(self,
-                 host_group_name="",
-                 host_list="",
-                 domain_name="",
-                 by_method=dsm_const.GLOBAL_BY_METHOD,
-                 user_name=dsm_const.DSM_USERNAME,
-                 password=dsm_const.DSM_PASSWORD,
-                 print_info_flag=False,
-                 print_exception=True,
-                 validate_flag=True):
+                              host_group_name="",
+                              host_list="",
+                              domain_name="",
+                              by_method=dsm_const.GLOBAL_BY_METHOD,
+                              user_name=dsm_const.DSM_USERNAME,
+                              password=dsm_const.DSM_PASSWORD,
+                              print_info_flag=False,
+                              print_exception=True,
+                              validate_flag=True):
         """Add host(s) to host group
         EP:
           HostPage / add host to host group
@@ -814,7 +823,7 @@
             validate : Flag to validate if host is added
         """
 
-        if not host_group_name :
+        if not host_group_name:
             raise CE.ArgumentValueNotProvided
         if not isinstance(host_list, list):
             host_list = [host_list]
@@ -829,34 +838,34 @@
                 locator=self.locator_dict['host_group_name_in_table'],
                 value_tuple=(host_group_name))
             self.EF.element_click(
-                                locator=self.locator_dict['hostgroup_edit_member_tab'])
+                locator=self.locator_dict['hostgroup_edit_member_tab'])
             self.EF.element_click(
-                    locator=self.locator_dict['add_btn'])
+                locator=self.locator_dict['add_btn'])
             for host_name in host_list:
                 self.EF.element_click(
-                        locator=self.locator_dict['hostgroup_host_cb_in_table'],
-                        value_tuple=(host_name))
+                    locator=self.locator_dict['hostgroup_host_cb_in_table'],
+                    value_tuple=(host_name))
                 self.EF.element_click(
-                        locator=self.locator_dict['hostgroup_add_host_ok_btn'])
+                    locator=self.locator_dict['hostgroup_add_host_ok_btn'])
                 self.EF.handle_alert(accept=True)
 
                 if validate_flag:
                     try:
                         self.EF.wait_for_element(locator=self.locator_dict['hostgroup_hostname_in_table'],
-                            value_tuple=(host_name), print_exception=False)
+                                                 value_tuple=(host_name), print_exception=False)
                     except Exception as _e:
                         raise CE.ValidateError
 
     def delete_host_from_hostgroup(self,
-                 host_group_name="",
-                 host_list=[],
-                 domain_name="",
-                 by_method=dsm_const.GLOBAL_BY_METHOD,
-                 user_name=dsm_const.DSM_USERNAME,
-                 password=dsm_const.DSM_PASSWORD,
-                 print_info_flag=False,
-                 print_exception=True,
-                 validate_flag=True):
+                                   host_group_name="",
+                                   host_list=[],
+                                   domain_name="",
+                                   by_method=dsm_const.GLOBAL_BY_METHOD,
+                                   user_name=dsm_const.DSM_USERNAME,
+                                   password=dsm_const.DSM_PASSWORD,
+                                   print_info_flag=False,
+                                   print_exception=True,
+                                   validate_flag=True):
         """delete host(s) from host group
         EP:
           HostPage / delete host from host group
@@ -885,32 +894,32 @@
                 locator=self.locator_dict['host_group_name_in_table'],
                 value_tuple=(host_group_name))
             self.EF.element_click(
-                                locator=self.locator_dict['hostgroup_edit_member_tab'])
+                locator=self.locator_dict['hostgroup_edit_member_tab'])
             for host_name in host_list:
                 self.EF.element_click(
-                        locator=self.locator_dict['hostgroup_host_cb_in_table'],
-                        value_tuple=(host_name))
+                    locator=self.locator_dict['hostgroup_host_cb_in_table'],
+                    value_tuple=(host_name))
                 self.EF.element_click(
-                        locator=self.locator_dict['delete_btn'])
+                    locator=self.locator_dict['delete_btn'])
                 self.EF.handle_alert(accept=True)
 
                 if validate_flag:
                     try:
                         self.EF.wait_for_element(locator=self.locator_dict['hostgroup_hostname_in_table'],
-                            value_tuple=(host_name), print_exception=False)
+                                                 value_tuple=(host_name), print_exception=False)
                         raise CE.ValidateError
                     except Exception as _e:
                         pass
 
     def delete_hostgroup(self,
-                 hostgroup_list=[],
-                 domain_name="",
-                 by_method=dsm_const.GLOBAL_BY_METHOD,
-                 user_name=dsm_const.DSM_USERNAME,
-                 password=dsm_const.DSM_PASSWORD,
-                 print_info_flag=False,
-                 print_exception=True,
-                 validate_flag=True):
+                         hostgroup_list=[],
+                         domain_name="",
+                         by_method=dsm_const.GLOBAL_BY_METHOD,
+                         user_name=dsm_const.DSM_USERNAME,
+                         password=dsm_const.DSM_PASSWORD,
+                         print_info_flag=False,
+                         print_exception=True,
+                         validate_flag=True):
         """Delete host group
         EP:
           HostPage / delete host group
@@ -925,22 +934,22 @@
         """
 
         if not isinstance(hostgroup_list, list):
-            hostgroup_list=[hostgroup_list]
+            hostgroup_list = [hostgroup_list]
 
         if by_method.lower() == "rest":
             if not domain_name:
                 raise CE.ArgumentValueNotProvided
             domain_id = rest_core_modules.get_domain_id(
-                            domain=domain_name)
+                domain=domain_name)
             hostgroup_api = HostGroup(dsm_url=dsm_const.DSM_URL, dsm_username=user_name,
-                            dsm_password=password, domain_id=domain_id)
+                                      dsm_password=password, domain_id=domain_id)
             rest_modules.bulkdelete_hostgroups(hostgroup_api, hostgroup_list)
 
         else:
             self.go_to_host_groups_page()
             for hostgroup in hostgroup_list:
                 self.EF.element_click(locator=self.locator_dict['hostgroup_cb'],
-                            value_tuple=(hostgroup), print_exception=False)
+                                      value_tuple=(hostgroup), print_exception=False)
                 self.EF.element_click(
                     locator=self.locator_dict['delete_btn'])
                 self.EF.handle_alert(accept=True)
@@ -948,20 +957,20 @@
                 if validate_flag:
                     try:
                         self.EF.wait_for_element(locator=self.locator_dict['host_group_name_in_table'],
-                            value_tuple=(hostgroup), print_exception=False)
+                                                 value_tuple=(hostgroup), print_exception=False)
                         raise CE.ValidateError
                     except Exception as _e:
                         pass
 
     def edit_hostgroup_general(self,
-                 edit_hostgroup_dict="",
-                 domain_name="",
-                 by_method=dsm_const.GLOBAL_BY_METHOD,
-                 user_name=dsm_const.DSM_USERNAME,
-                 password=dsm_const.DSM_PASSWORD,
-                 print_info_flag=False,
-                 print_exception=True,
-                 validate_flag=True):
+                               edit_hostgroup_dict="",
+                               domain_name="",
+                               by_method=dsm_const.GLOBAL_BY_METHOD,
+                               user_name=dsm_const.DSM_USERNAME,
+                               password=dsm_const.DSM_PASSWORD,
+                               print_info_flag=False,
+                               print_exception=True,
+                               validate_flag=True):
         """Edit host group
         EP:
           HostPage / Edit host group
@@ -987,13 +996,13 @@
                 locator=self.locator_dict['host_group_name_in_table'],
                 value_tuple=(edit_hostgroup_dict['name']))
             self.EF.element_click(
-                                locator=self.locator_dict['hostgroup_edit_general_tab'])
-            #default host group form fields dict
+                locator=self.locator_dict['hostgroup_edit_general_tab'])
+            # default host group form fields dict
             default_edit_hostgroup_dict = {
-                    "enable_fs_comm" : self.locator_dict['hostgroup_edit_enable_comm_cb'],
-                    "desc" : self.locator_dict['host_host_group_add_host_group_description_input'],
-                    }
-            #form list
+                "enable_fs_comm": self.locator_dict['hostgroup_edit_enable_comm_cb'],
+                "desc": self.locator_dict['host_host_group_add_host_group_description_input'],
+            }
+            # form list
             form_list = []
             for key in edit_hostgroup_dict:
                 try:
@@ -1002,30 +1011,29 @@
                 except KeyError:
                     pass
             form_list.append({'locator': self.locator_dict['ok_btn'],
-                          'value': 'button'})
+                              'value': 'button'})
             self.EF.fill_form(form_list=form_list,
-                  print_info_flag=print_info_flag,
-                  print_exception=print_exception)
+                              print_info_flag=print_info_flag,
+                              print_exception=print_exception)
 
             if validate_flag:
                 try:
                     self.EF.element_click(locator=self.locator_dict['host_group_name_in_table'],
                                           value_tuple=(edit_hostgroup_dict['name']))
                     self.EF.validate_form_entries(form_list=form_list, print_info_flag=print_info_flag,
-                                                   print_exception=print_exception)
+                                                  print_exception=print_exception)
                 except Exception as _e:
                     raise CE.ValidateError
 
-
     def add_guardpoint_to_hostgroup(self,
-                 guardpoint_hostgroup_dict="",
-                 domain_name="",
-                 by_method=dsm_const.GLOBAL_BY_METHOD,
-                 user_name=dsm_const.DSM_USERNAME,
-                 password=dsm_const.DSM_PASSWORD,
-                 print_info_flag=False,
-                 print_exception=True,
-                 validate_flag=True):
+                                    guardpoint_hostgroup_dict="",
+                                    domain_name="",
+                                    by_method=dsm_const.GLOBAL_BY_METHOD,
+                                    user_name=dsm_const.DSM_USERNAME,
+                                    password=dsm_const.DSM_PASSWORD,
+                                    print_info_flag=False,
+                                    print_exception=True,
+                                    validate_flag=True):
         """Edit host group
         EP:
           HostPage / Add guardpoint(s) to host group
@@ -1051,17 +1059,17 @@
                 locator=self.locator_dict['host_group_name_in_table'],
                 value_tuple=(guardpoint_hostgroup_dict['name']))
             self.EF.element_click(
-                                locator=self.locator_dict['hostgroup_edit_guardpoint_tab'])
+                locator=self.locator_dict['hostgroup_edit_guardpoint_tab'])
             self.EF.element_click(
-                                locator=self.locator_dict['guard_btn'])
-            #default host group form fields dict
+                locator=self.locator_dict['guard_btn'])
+            # default host group form fields dict
             default_guardpoint_hostgroup_dict = {
-                    "host_browser" : self.locator_dict['hostgroup_edit_enable_comm_cb'],
-                    "policy" : self.locator_dict['select_guardpoint_policy'],
-                    "type" : self.locator_dict['select_guardpoint_type'],
-                    "path" : self.locator_dict['guardpoint_path_textarea'],
-                    }
-            #form list
+                "host_browser": self.locator_dict['hostgroup_edit_enable_comm_cb'],
+                "policy": self.locator_dict['select_guardpoint_policy'],
+                "type": self.locator_dict['select_guardpoint_type'],
+                "path": self.locator_dict['guardpoint_path_textarea'],
+            }
+            # form list
             form_list = []
             for key in guardpoint_hostgroup_dict:
                 try:
@@ -1070,17 +1078,15 @@
                 except KeyError:
                     pass
             form_list.append({'locator': self.locator_dict['ok_btn'],
-                          'value': 'button'})
+                              'value': 'button'})
             self.EF.fill_form(form_list=form_list,
-                  print_info_flag=print_info_flag,
-                  print_exception=print_exception)
+                              print_info_flag=print_info_flag,
+                              print_exception=print_exception)
 
         if validate_flag:
             try:
                 self.EF.wait_for_element(locator=self.locator_dict['hostgroup_edit_guardpoint_protected_path'],
-                    value_tuple=(guardpoint_hostgroup_dict['path']), print_exception=False)
+                                         value_tuple=(guardpoint_hostgroup_dict['path']), print_exception=False)
                 raise CE.ValidateError
             except Exception as _e:
                 pass
-
-
Index: Application/DSM/DSMPages/LoginPage.py
===================================================================
--- Application/DSM/DSMPages/LoginPage.py	(revision 74135)
+++ Application/DSM/DSMPages/LoginPage.py	(working copy)
@@ -97,25 +97,28 @@
         self.go_to_login_page(dsm_url=dsm_url)
 
         form_list = [
-        {'locator':self.locator_dict['login_username_txt'], 'value':user_name},
-        {'locator':self.locator_dict['login_password_txt'], 'value': password},
-        {'locator':self.locator_dict['login_login_btn'], 'value': 'click'},
+            {'locator': self.locator_dict['login_username_txt'],
+                'value':user_name},
+            {'locator': self.locator_dict['login_password_txt'],
+                'value': password},
+            {'locator': self.locator_dict['login_login_btn'],
+                'value': 'click'},
         ]
 
         self.EF.fill_form(form_list)
 
-       # if user_name != dsm_const.DSM_USERNAME:
+        # if user_name != dsm_const.DSM_USERNAME:
         try:
             self.change_password(user_name=user_name,
-                                password=password,
-                                new_password=new_password,
-                                print_exception=print_exception,
-                                do_sanity_check=do_change_password_sanity_check)
+                                 password=password,
+                                 new_password=new_password,
+                                 print_exception=print_exception,
+                                 do_sanity_check=do_change_password_sanity_check)
         except Exception:
             if print_exception:
                 RB.print_info("Password has not expired")
         if validate_login:
-                self.validate_login()
+            self.validate_login()
         return True
 
     def change_password_page_sanity_check(self):
@@ -159,15 +162,17 @@
             self.change_password_page_sanity_check()
 
         form_list = [
-        {'locator': self.locator_dict['login_change_password_old_password_txt'], 'value': password},
-        {'locator': self.locator_dict['login_change_password_new_password_txt'], 'value': new_password},
-        {'locator': self.locator_dict['login_change_password_confirm_new_password_txt'], 'value': new_password},
-        {'locator': self.locator_dict['ok_btn'], 'value':'click'},
+            {'locator': self.locator_dict['login_change_password_old_password_txt'],
+                'value': password},
+            {'locator': self.locator_dict['login_change_password_new_password_txt'],
+                'value': new_password},
+            {'locator': self.locator_dict[
+                'login_change_password_confirm_new_password_txt'],
+                'value': new_password},
+            {'locator': self.locator_dict['ok_btn'], 'value':'click'},
         ]
         self.EF.fill_form(form_list=form_list)
         self.logout(print_exception=print_exception)
         self.login(user_name=user_name,
                    password=dsm_const.DEFAULT_NEW_PASSWORD,
                    print_exception=print_exception)
-
-
Index: Application/DSM/DSMPages/PoliciesPage.py
===================================================================
--- Application/DSM/DSMPages/PoliciesPage.py	(revision 74135)
+++ Application/DSM/DSMPages/PoliciesPage.py	(working copy)
@@ -28,11 +28,12 @@
 from PageObjectModel.WebDriverUtility.GetWebDriver import GetWebDriver
 from PageObjectModel.ExternalToolLib.ElementryFunctions import ElementryFunctions as EF
 
-#rest modules
+# rest modules
 from dsm.rest.modules import core_modules as rest_core_modules
 from dsm.rest.modules import modules as rest_modules
 from dsm.rest.objects.policy_object import Policy
 
+
 class PoliciesPage(BasePage):
     """
     policies_page class provides all the functions
@@ -73,8 +74,7 @@
         Returns True or False depending on the result.
         """
 
-        RB.print_info(text=
-                      "Performing Policies Page Sanity Check")
+        RB.print_info(text="Performing Policies Page Sanity Check")
         element = None
         try:
             (element,
@@ -178,8 +178,7 @@
         Returns True or False depending on the result.
         """
 
-        RB.print_info(text=
-                      "Performing Resource Sets Page Sanity Check")
+        RB.print_info(text="Performing Resource Sets Page Sanity Check")
         element = None
         try:
             (element,
@@ -293,8 +292,7 @@
         Returns True or False depending on the result.
         """
 
-        RB.print_info(text=
-                      "Performing User Sets Page Sanity Check")
+        RB.print_info(text="Performing User Sets Page Sanity Check")
         element = None
         try:
             (element,
@@ -407,8 +405,7 @@
         Returns True or False depending on the result.
         """
 
-        RB.print_info(text=
-                      "Performing Process Sets Page Sanity Check")
+        RB.print_info(text="Performing Process Sets Page Sanity Check")
         element = None
         try:
             (element,
@@ -520,8 +517,7 @@
         Returns True or False depending on the result.
         """
 
-        RB.print_info(text=
-                      "Performing Time Sets Page Sanity Check")
+        RB.print_info(text="Performing Time Sets Page Sanity Check")
         element = None
         try:
             (element,
@@ -637,8 +633,7 @@
         Returns True or False depending on the result.
         """
 
-        RB.print_info(text=
-                      "Performing Agent Object Page Sanity Check")
+        RB.print_info(text="Performing Agent Object Page Sanity Check")
         element = None
         try:
             (element,
@@ -709,8 +704,8 @@
         Returns True or False depending on the result.
         """
 
-        RB.print_info(text=
-                      "Performing Import Export Policies Page Sanity Check")
+        RB.print_info(
+            text="Performing Import Export Policies Page Sanity Check")
         element = None
         try:
             (element,
@@ -791,22 +786,23 @@
                 value_tuple=(policy_name), print_exception=print_exception)
             if element:
                 RB.print_info(
-                        text="Policy [%s] found on manage policies page.\n" %policy_name)
+                    text="Policy [%s] found on manage policies page.\n" % policy_name)
                 return True
         except Exception as _e:
             RB.print_err(text=_e)
-            RB.print_info(text="Policy [%s] not found on manage policies page.\n" %policy_name)
+            RB.print_info(
+                text="Policy [%s] not found on manage policies page.\n" % policy_name)
             return False
 
     def add_policy(self,
-                 policy_dict={},
-                 domain_name="",
-                 by_method=dsm_const.GLOBAL_BY_METHOD,
-                 user_name=dsm_const.DSM_USERNAME,
-                 password=dsm_const.DSM_PASSWORD,
-                 print_info_flag=False,
-                 print_exception=True,
-                 validate_flag=True):
+                   policy_dict={},
+                   domain_name="",
+                   by_method=dsm_const.GLOBAL_BY_METHOD,
+                   user_name=dsm_const.DSM_USERNAME,
+                   password=dsm_const.DSM_PASSWORD,
+                   print_info_flag=False,
+                   print_exception=True,
+                   validate_flag=True):
         """Add policy
         EP:
           PoliciesPage / add policy
@@ -823,51 +819,64 @@
         if policy_dict is {}:
             raise self.CE.ArgumentValueNotProvided
 
-        RB.print_info(text="Adding policy [%s].\n" %policy_dict['name'])
+        RB.print_info(text="Adding policy [%s].\n" % policy_dict['name'])
         if by_method.lower() == "rest":
             raise CE.MethodNotImplimented
 
         else:
             self.go_to_policies_page()
             self.EF.element_click(
-                    locator=self.locator_dict['add_btn'])
+                locator=self.locator_dict['add_btn'])
             form_list = [
-                        {'locator' : self.locator_dict['policies_add_policy_policy_type_ddl'],
-                        'value': policy_dict['policy_type']},
-                        {'locator': self.locator_dict['policies_add_policy_name_text'],
-                        'value' : policy_dict['name']},
-                        ]
+                {'locator': self.locator_dict['policies_add_policy_policy_type_ddl'],
+                 'value': policy_dict['policy_type']},
+                {'locator': self.locator_dict['policies_add_policy_name_text'],
+                 'value': policy_dict['name']},
+            ]
             self.EF.fill_form(form_list=form_list,
-                  print_info_flag=print_info_flag,
-                  print_exception=print_exception)
+                              print_info_flag=print_info_flag,
+                              print_exception=print_exception)
             try:
                 if policy_dict['keyname']:
                     self.EF.element_click(
-                            locator=self.locator_dict['policies_add_policy_key_selection_rules_add_btn'])
+                        locator=self.locator_dict[
+                            'policies_add_policy_key_selection_rules_add_btn'])
                     self.EF.element_click(
-                            locator=self.locator_dict['policies_add_policy_key_selection_rules_select_btn'])
+                        locator=self.locator_dict[
+                            'policies_add_policy_key_selection_rules_select_btn'])
+
+                    self.EF.send_keys(
+                        data=policy_dict['keyname'],
+                        locator=self.locator_dict[
+                            'policies_add_policy_key_selection_rules_search_box_keyname'])
+
+                    self.EF.element_click(locator=self.locator_dict['go_btn'])
+
                     self.EF.element_click(
-                            locator=self.locator_dict['policies_add_policy_key_selection_rules_select_keyname'],
-                                                value_tuple=(policy_dict['keyname']))
+                        locator=self.locator_dict[
+                            'policies_add_policy_key_selection_rules_select_keyname'],
+                        value_tuple=(policy_dict['keyname']))
                     self.EF.element_click(
-                            locator=self.locator_dict['policies_add_policy_key_selection_rules_select_key_btn'])
+                        locator=self.locator_dict[
+                            'policies_add_policy_key_selection_rules_select_key_btn'])
                     self.EF.element_click(
-                            locator=self.locator_dict['ok_btn'])
+                        locator=self.locator_dict['ok_btn'])
+
             except KeyError:
                 pass
-        self.EF.wait_for_element(locator=self.locator_dict['ok_btn'])
+        self.EF.wait_for_element(locator=self.locator_dict['apply_btn'])
         self.EF.element_click(locator=self.locator_dict['ok_btn'])
 
         if validate_flag:
-           if not self.search_policy(policy_name=policy_dict['name']):
+            if not self.search_policy(policy_name=policy_dict['name']):
                 raise CE.ValidateError
 
     def total_policies_count(self, domain_name='',
-                                 by_method=dsm_const.GLOBAL_BY_METHOD,
-                                 user_name=dsm_const.DSM_USERNAME,
-                                 password=dsm_const.DSM_PASSWORD,
-                                 print_info_flag=False,
-                                 print_exception=True):
+                             by_method=dsm_const.GLOBAL_BY_METHOD,
+                             user_name=dsm_const.DSM_USERNAME,
+                             password=dsm_const.DSM_PASSWORD,
+                             print_info_flag=False,
+                             print_exception=True):
         """This gives total count for policies on DSM
         EP:
             PoliciesPage / get total policies count
@@ -888,13 +897,13 @@
             return self.retrieve_total_count_in_table()
 
     def delete_policy(self,
-                    policy_list=[],
-                    domain_name="",
-                    by_method=dsm_const.GLOBAL_BY_METHOD,
-                    user_name=dsm_const.DSM_USERNAME,
-                    password=dsm_const.DSM_PASSWORD,
-                    deregister_flag=True,
-                    validate_flag=True):
+                      policy_list=[],
+                      domain_name="",
+                      by_method=dsm_const.GLOBAL_BY_METHOD,
+                      user_name=dsm_const.DSM_USERNAME,
+                      password=dsm_const.DSM_PASSWORD,
+                      deregister_flag=True,
+                      validate_flag=True):
         """Delete policy from a domain
         EP:
           PoliciesPage / delete policy
@@ -915,11 +924,12 @@
             if not domain_name:
                 raise CE.ArgumentValueNotProvided
             domain_id = rest_core_modules.get_domain_id(
-                            domain=domain_name)
+                domain=domain_name)
             policy_api = Policy(dsm_url=dsm_const.DSM_URL, dsm_username=user_name,
-                            dsm_password=password, domain_id=domain_id)
+                                dsm_password=password, domain_id=domain_id)
             for host_name in policy_list:
-                host_id = rest_core_modules.get_host_id(user_name, domain_id, host_name)
+                host_id = rest_core_modules.get_host_id(
+                    user_name, domain_id, host_name)
                 rest_modules.delete_policies(policy_api, payload=policy_list)
 
         else:
@@ -961,8 +971,7 @@
             raise CE.ArgumentNotProvided(
                 "Time set name is mandatory for search")
 
-        RB.print_info(text=
-                      "Performing time set search by [%s]" % by_method)
+        RB.print_info(text="Performing time set search by [%s]" % by_method)
         if by_method.lower() == "rest":
             # REST API NOT AVAILABLE
             raise CE.MethodNotImplemented
@@ -988,12 +997,12 @@
                 pass
 
             if element is None:
-                RB.print_err(text=
-                             "Time set [%s] is not present in the table" % time_set_name)
+                RB.print_err(
+                    text="Time set [%s] is not present in the table" % time_set_name)
                 return False
             else:
-                RB.print_info(text=
-                              "Time set [%s] search successful in the table" % time_set_name)
+                RB.print_info(
+                    text="Time set [%s] search successful in the table" % time_set_name)
                 return True
 
     def add_time_sets(self, time_set_dict={},
@@ -1032,12 +1041,11 @@
             if time_set_dict['time_set_name'] in ("", None):
                 raise CE.ArgumentValueNotProvided
         except KeyError:
-            RB.print_err(text=
-                         "Wrong Time Set dictionary passed without time set name key")
+            RB.print_err(
+                text="Wrong Time Set dictionary passed without time set name key")
             raise KeyError
 
-        RB.print_info(text=
-                      "Performing time set add by [%s]" % by_method)
+        RB.print_info(text="Performing time set add by [%s]" % by_method)
         if by_method.lower() == "rest":
             # REST API NOT AVAILABLE
             raise CE.MethodNotImplemented
@@ -1046,8 +1054,8 @@
             raise CE.MethodNotImplemented
         else:
             if self.search_time_sets(time_set_name=time_set_dict['time_set_name']):
-                RB.print_err(text=
-                             "Time Set [%s] is already added in the domain" % time_set_dict['time_set_name'])
+                RB.print_err(
+                    text="Time Set [%s] is already added in the domain" % time_set_dict['time_set_name'])
                 return False
             else:
                 self.EF.element_click(locator=self.locator_dict['add_btn'])
@@ -1069,8 +1077,8 @@
                 except Exception:
                     pass
                 if element is not None:
-                    RB.print_err(text=
-                                 "Error while adding time set [%s]"%time_set_dict['time_set_name'])
+                    RB.print_err(
+                        text="Error while adding time set [%s]" % time_set_dict['time_set_name'])
                     return False
 
                 if "time_dict" in time_set_dict.keys():
@@ -1115,8 +1123,7 @@
             raise CE.ArgumentValueNotProvided(
                 "Time set name is mandatory for adding time")
 
-        RB.print_info(text=
-                      "Performing time add by [%s]" % by_method)
+        RB.print_info(text="Performing time add by [%s]" % by_method)
         if by_method.lower() == "rest":
             # REST API NOT AVAILABLE
             raise CE.MethodNotImplemented
@@ -1125,8 +1132,8 @@
             raise CE.MethodNotImplemented
         else:
             if not self.search_time_sets(time_set_name=time_set_name):
-                RB.print_err(text=
-                             "Time Set [%s] is not present in the domain" % time_set_name)
+                RB.print_err(
+                    text="Time Set [%s] is not present in the domain" % time_set_name)
                 return False
             else:
                 self.EF.element_click(locator=self.locator_dict['policies_manage_policies_time_sets_time_set_name'],
@@ -1154,7 +1161,7 @@
                      "value": time_dict['end_time_am_pm']},
                     {"locator": self.locator_dict['ok_btn'],
                      "value": "click"}
-                    ]
+                ]
 
                 self.EF.fill_form(form_list=form_list,
                                   print_info_flag=print_info_flag,
@@ -1173,12 +1180,12 @@
                     pass
 
                 if element is None:
-                    RB.print_info(text=
-                                  "Time added successfully in time set [%s]"%time_set_name)
+                    RB.print_info(
+                        text="Time added successfully in time set [%s]" % time_set_name)
                 else:
-                    RB.print_err(text=
-                                 "Missing values in time dict")
-                    self.EF.element_click(locator=self.locator_dict['cancel_btn'])
+                    RB.print_err(text="Missing values in time dict")
+                    self.EF.element_click(
+                        locator=self.locator_dict['cancel_btn'])
                     raise CE.ValidateError
 
     def delete_all_time_from_timeset(self,
@@ -1205,8 +1212,7 @@
         if time_set_name in ("", None):
             raise CE.ArgumentValueNotProvided
 
-        RB.print_info(text=
-                      "Performing time delete by [%s]" % by_method)
+        RB.print_info(text="Performing time delete by [%s]" % by_method)
         if by_method.lower() == "rest":
             # REST API NOT AVAILABLE
             raise CE.MethodNotImplemented
@@ -1215,15 +1221,17 @@
             raise CE.MethodNotImplemented
         else:
             if not self.search_time_sets(time_set_name=time_set_name):
-                RB.print_err(text=
-                             "Time Set [%s] is not present in the domain" % time_set_name)
+                RB.print_err(
+                    text="Time Set [%s] is not present in the domain" % time_set_name)
                 raise CE.ValidateError
             else:
                 self.EF.element_click(locator=self.locator_dict['policies_manage_policies_time_sets_time_set_name'],
                                       value_tuple=(time_set_name))
                 while self.retrieve_total_count_in_table() != 0:
-                    self.EF.select_element(locator=self.locator_dict['select_all_cb'])
-                    self.EF.element_click(locator=self.locator_dict['delete_btn'])
+                    self.EF.select_element(
+                        locator=self.locator_dict['select_all_cb'])
+                    self.EF.element_click(
+                        locator=self.locator_dict['delete_btn'])
                     self.EF.handle_alert()
                     self.wait_for_menubar_to_load()
 
@@ -1268,8 +1276,7 @@
 
         for time_set_name in time_set_name_list:
 
-            RB.print_info(text=
-                          "Deleting time set [%s] \
+            RB.print_info(text="Deleting time set [%s] \
             from domain [%s] by [%s]" % (time_set_name,
                                          domain_name,
                                          by_method))
@@ -1328,8 +1335,7 @@
             raise CE.ArgumentNotProvided(
                 "Process set name is mandatory for search")
 
-        RB.print_info(text=
-                      "Performing process set search by [%s]" % by_method)
+        RB.print_info(text="Performing process set search by [%s]" % by_method)
         if by_method.lower() == "rest":
             # REST API NOT AVAILABLE
             raise CE.MethodNotImplemented
@@ -1355,12 +1361,12 @@
                 pass
 
             if element is None:
-                RB.print_err(text=
-                             "Process set [%s] is not present in the table" % process_set_name)
+                RB.print_err(
+                    text="Process set [%s] is not present in the table" % process_set_name)
                 return False
             else:
-                RB.print_info(text=
-                              "Process set [%s] search successful in the table" % process_set_name)
+                RB.print_info(
+                    text="Process set [%s] search successful in the table" % process_set_name)
                 return True
 
     def add_process_sets(self, process_set_dict={},
@@ -1393,12 +1399,11 @@
             if not process_set_dict['process_set_name']:
                 raise CE.ArgumentValueNotProvided
         except KeyError:
-            RB.print_err(text=
-                         "Wrong Process Set dictionary passed without process set name key")
+            RB.print_err(
+                text="Wrong Process Set dictionary passed without process set name key")
             raise KeyError
 
-        RB.print_info(text=
-                      "Performing process set add by [%s]" % by_method)
+        RB.print_info(text="Performing process set add by [%s]" % by_method)
         if by_method.lower() == "rest":
             # REST API NOT AVAILABLE
             raise CE.MethodNotImplemented
@@ -1407,8 +1412,8 @@
             raise CE.MethodNotImplemented
         else:
             if self.search_process_sets(process_set_name=process_set_dict['process_set_name']):
-                RB.print_err(text=
-                             "Process Set [%s] is already added in the domain" % process_set_dict['process_set_name'])
+                RB.print_err(
+                    text="Process Set [%s] is already added in the domain" % process_set_dict['process_set_name'])
                 return False
             else:
                 self.EF.element_click(locator=self.locator_dict['add_btn'])
@@ -1430,8 +1435,8 @@
                 except Exception:
                     pass
                 if element is not None:
-                    RB.print_err(text=
-                                 "Error while adding Process set [%s]"%process_set_dict['process_set_name'])
+                    RB.print_err(
+                        text="Error while adding Process set [%s]" % process_set_dict['process_set_name'])
                     return False
 
                 if validate_flag:
@@ -1473,8 +1478,7 @@
             raise CE.ArgumentValueNotProvided(
                 "Process set name is mandatory for adding process")
 
-        RB.print_info(text=
-                      "Performing process add by [%s]" % by_method)
+        RB.print_info(text="Performing process add by [%s]" % by_method)
         if by_method.lower() == "rest":
             # REST API NOT AVAILABLE
             raise CE.MethodNotImplemented
@@ -1483,8 +1487,8 @@
             raise CE.MethodNotImplemented
         else:
             if not self.search_process_sets(process_set_name=process_set_name):
-                RB.print_err(text=
-                             "Process Set [%s] is not present in the domain" % process_set_name)
+                RB.print_err(
+                    text="Process Set [%s] is not present in the domain" % process_set_name)
                 return False
             else:
                 self.EF.element_click(locator=self.locator_dict['policies_manage_policies_process_sets_process_set_name'],
@@ -1502,7 +1506,7 @@
                      "value": process_dict['file']},
                     {"locator": self.locator_dict['ok_btn'],
                      "value": "click"}
-                    ]
+                ]
 
                 self.EF.fill_form(form_list=form_list,
                                   print_info_flag=print_info_flag,
@@ -1522,12 +1526,12 @@
                         pass
 
                     if element is None:
-                        RB.print_info(text=
-                                      "Process added successfully in process set [%s]"%process_set_name)
+                        RB.print_info(
+                            text="Process added successfully in process set [%s]" % process_set_name)
                     else:
-                        RB.print_err(text=
-                                     "Missing values in process dict")
-                        self.EF.element_click(locator=self.locator_dict['cancel_btn'])
+                        RB.print_err(text="Missing values in process dict")
+                        self.EF.element_click(
+                            locator=self.locator_dict['cancel_btn'])
                         raise CE.ValidateError
 
     def delete_process_sets(self,
@@ -1558,8 +1562,7 @@
 
         for process_set_name in process_set_name_list:
 
-            RB.print_info(text=
-                          "Deleting process set [%s] \
+            RB.print_info(text="Deleting process set [%s] \
                           from domain [%s] by [%s]" % (process_set_name,
                                                        domain_name,
                                                        by_method))
@@ -1613,8 +1616,7 @@
         if user_set_name == "":
             raise CE.ArgumentNotProvided
 
-        RB.print_info(text=
-                      "Performing User set search by [%s]" % by_method)
+        RB.print_info(text="Performing User set search by [%s]" % by_method)
         if by_method.lower() == "rest":
             # REST API NOT AVAILABLE
             raise CE.MethodNotImplemented
@@ -1640,12 +1642,12 @@
                 pass
 
             if element is None:
-                RB.print_err(text=
-                             "User set [%s] is not present in the table" % user_set_name)
+                RB.print_err(
+                    text="User set [%s] is not present in the table" % user_set_name)
                 return False
             else:
-                RB.print_info(text=
-                              "User set [%s] search successful in the table" % user_set_name)
+                RB.print_info(
+                    text="User set [%s] search successful in the table" % user_set_name)
                 return True
 
     def add_user_sets(self, user_set_dict={},
@@ -1676,12 +1678,11 @@
             if not user_set_dict['user_set_name']:
                 raise CE.ArgumentValueNotProvided
         except KeyError:
-            RB.print_err(text=
-                         "Wrong User Set dictionary passed without user set name key")
+            RB.print_err(
+                text="Wrong User Set dictionary passed without user set name key")
             raise KeyError
 
-        RB.print_info(text=
-                      "Performing user set add by [%s]" % by_method)
+        RB.print_info(text="Performing user set add by [%s]" % by_method)
         if by_method.lower() == "rest":
             # REST API NOT AVAILABLE
             raise CE.MethodNotImplemented
@@ -1690,8 +1691,8 @@
             raise CE.MethodNotImplemented
         else:
             if self.search_user_sets(user_set_name=user_set_dict['user_set_name']):
-                RB.print_err(text=
-                             "User Set [%s] is already added in the domain" % user_set_dict['user_set_name'])
+                RB.print_err(
+                    text="User Set [%s] is already added in the domain" % user_set_dict['user_set_name'])
                 return False
             else:
                 self.EF.element_click(locator=self.locator_dict['add_btn'])
@@ -1714,8 +1715,8 @@
                     except Exception:
                         pass
                     if element is not None:
-                        RB.print_err(text=
-                                     "Error while adding User set [%s]"%user_set_dict['user_set_name'])
+                        RB.print_err(
+                            text="Error while adding User set [%s]" % user_set_dict['user_set_name'])
                         raise CE.ValidateError
 
                     if not self.search_user_sets(user_set_name=user_set_dict['user_set_name']):
@@ -1853,8 +1854,7 @@
 
         for user_set_name in user_set_name_list:
 
-            RB.print_info(text=
-                          "Deleting user set [%s] \
+            RB.print_info(text="Deleting user set [%s] \
                           from domain [%s] by [%s]" % (user_set_name,
                                                        domain_name,
                                                        by_method))
@@ -1908,8 +1908,8 @@
         if resource_set_name == "":
             raise CE.ArgumentNotProvided
 
-        RB.print_info(text=
-                      "Performing Resource set search by [%s]" % by_method)
+        RB.print_info(
+            text="Performing Resource set search by [%s]" % by_method)
         if by_method.lower() == "rest":
             # REST API NOT AVAILABLE
             raise CE.MethodNotImplemented
@@ -1935,21 +1935,21 @@
                 pass
 
             if element is None:
-                RB.print_err(text=
-                             "Resource set [%s] is not present in the table" % resource_set_name)
+                RB.print_err(
+                    text="Resource set [%s] is not present in the table" % resource_set_name)
                 return False
             else:
-                RB.print_info(text=
-                              "Resource set [%s] search successful in the table" % resource_set_name)
+                RB.print_info(
+                    text="Resource set [%s] search successful in the table" % resource_set_name)
                 return True
 
     def add_resource_sets(self, resource_set_dict={},
-                      by_method=dsm_const.GLOBAL_BY_METHOD,
-                      print_exception=True,
-                      username=dsm_const.DSM_USERNAME,
-                      password=dsm_const.DSM_PASSWORD,
-                      dsm_url=dsm_const.DSM,
-                      validate_flag=True):
+                          by_method=dsm_const.GLOBAL_BY_METHOD,
+                          print_exception=True,
+                          username=dsm_const.DSM_USERNAME,
+                          password=dsm_const.DSM_PASSWORD,
+                          dsm_url=dsm_const.DSM,
+                          validate_flag=True):
         """Add resource sets in policies page using given arguments.
         EP:
           PoliciesPage / add resource sets
@@ -1971,12 +1971,11 @@
             if resource_set_dict['resource_set_name'] in ("", None):
                 raise CE.ArgumentValueNotProvided
         except KeyError:
-            RB.print_err(text=
-                         "Wrong Resource Set dictionary passed without resource set name key")
+            RB.print_err(
+                text="Wrong Resource Set dictionary passed without resource set name key")
             raise KeyError
 
-        RB.print_info(text=
-                      "Performing resource set add by [%s]" % by_method)
+        RB.print_info(text="Performing resource set add by [%s]" % by_method)
         if by_method.lower() == "rest":
             # REST API NOT AVAILABLE
             raise CE.MethodNotImplemented
@@ -1985,8 +1984,8 @@
             raise CE.MethodNotImplemented
         else:
             if self.search_resource_sets(resource_set_name=resource_set_dict['resource_set_name']):
-                RB.print_err(text=
-                             "Resource Set [%s] is already added in the domain" % resource_set_dict['resource_set_name'])
+                RB.print_err(
+                    text="Resource Set [%s] is already added in the domain" % resource_set_dict['resource_set_name'])
                 return False
             else:
                 self.EF.element_click(locator=self.locator_dict['add_btn'])
@@ -2009,8 +2008,8 @@
                     except Exception:
                         pass
                     if element is not None:
-                        RB.print_err(text=
-                                     "Error while adding Resource set [%s]"%resource_set_dict['resource_set_name'])
+                        RB.print_err(
+                            text="Error while adding Resource set [%s]" % resource_set_dict['resource_set_name'])
                         raise CE.ValidateError
 
                     if not self.search_resource_sets(resource_set_name=resource_set_dict['resource_set_name']):
@@ -2147,8 +2146,7 @@
 
         for resource_set_name in resource_set_name_list:
 
-            RB.print_info(text=
-                          "Deleting resource set [%s] \
+            RB.print_info(text="Deleting resource set [%s] \
                           from domain [%s] by [%s]" % (resource_set_name,
                                                        domain_name,
                                                        by_method))
@@ -2180,4 +2178,3 @@
                         raise CE.ValidateError
                     except CE.ElementNotFound:
                         pass
-
Index: Application/DSM/DSMPages/WrapperKeyPage.py
===================================================================
--- Application/DSM/DSMPages/WrapperKeyPage.py	(revision 74135)
+++ Application/DSM/DSMPages/WrapperKeyPage.py	(working copy)
@@ -11,7 +11,6 @@
 
 # Standard python library
 import sys
-import time
 from os.path import abspath, dirname, join
 
 # Update System path
@@ -20,8 +19,6 @@
 
 from dsm.rest.modules import core_modules as rest_core_modules
 from dsm.rest.modules import modules as rest_modules
-from dsm.rest.objects.domain_object import Domain
-from dsm.rest.objects.admin_object import Admin
 from dsm.rest.objects.wrapperkey_object import WrapperKey
 from PageObjectModel.CommonUtilities import CustomException as CE
 
@@ -54,17 +51,18 @@
             dsm_password: Password
         """
         self.driver = driver
-        super(WrapperKeyPage, self).__init__(driver=self.driver, version=version)
+        super(WrapperKeyPage, self).__init__(
+            driver=self.driver, version=version)
         self.EF = EF(self.driver)
 
     def create_wrapper_key(self,
-                      domain_name='',
-                      by_method=dsm_const.GLOBAL_BY_METHOD,
-                      user_name=dsm_const.DSM_USERNAME,
-                      password=dsm_const.DSM_PASSWORD,
-                      print_info_flag=False,
-                      print_exception=True,
-                      validate_flag=True):
+                           domain_name='',
+                           by_method=dsm_const.GLOBAL_BY_METHOD,
+                           user_name=dsm_const.DSM_USERNAME,
+                           password=dsm_const.DSM_PASSWORD,
+                           print_info_flag=False,
+                           print_exception=True,
+                           validate_flag=True):
         """Create wrapper key using given arguments.
         EP:
           WrapperKeyPage / create  wrapperkey
@@ -79,7 +77,7 @@
         if by_method.lower() == "rest":
             if domain_name:
                 domain_id = rest_core_modules.get_domain_id(
-                                            domain=domain_name)
+                    domain=domain_name)
                 description = "pom wrapper key"
                 wk_api = WrapperKey(dsm_url=dsm_const.DSM_URL,
                                     dsm_username=user_name,
@@ -93,7 +91,7 @@
             return data
         else:
             raise CE.MethodNotImplemented
-            #TODO: GUI implementation for wrapper key is pending
+            # TODO: GUI implementation for wrapper key is pending
 
     def export_keyshare(self, export_keyshare='',
                         custodian_admin_list=[],
@@ -103,7 +101,6 @@
                         print_info_flag=False,
                         print_exception=True,
                         validate_flag=True):
-
         """Export keyshare using given arguments.
         EP:
             WrapperKeyPage / export keyshare
@@ -118,36 +115,45 @@
         if not export_keyshare:
             raise CE.ArgumentValueNotProvided
         if by_method.lower() == "rest":
-             raise CE.MethodNotImplemented
+            raise CE.MethodNotImplemented
 
         else:
             if not isinstance(custodian_admin_list, list):
                 custodian_admin_list = [custodian_admin_list]
             form_list = [
-                        {'locator' : self.locator_dict['system_wrapper_keys_operation_ddl'],
-                        'value': 'Export'},
-                        {'locator': self.locator_dict['system_wrapper_keys_min_custodians_txtbx'],
-                        'value' : export_keyshare['minimumNumberOfShares']},
-                        {'locator' : self.locator_dict['system_wrapper_keys_total_custodians_txtbx'],
-                        'value' : export_keyshare['totalNumberOfShares']}
-                        ]
+                {'locator': self.locator_dict['system_wrapper_keys_operation_ddl'],
+                 'value': 'Export'},
+                {'locator': self.locator_dict['system_wrapper_keys_min_custodians_txtbx'],
+                 'value': export_keyshare['minimumNumberOfShares']},
+                {'locator': self.locator_dict[
+                    'system_wrapper_keys_total_custodians_txtbx'],
+                    'value': export_keyshare['totalNumberOfShares']}
+            ]
 
             for admin in custodian_admin_list:
-                custodian_locator = {'locator': self.locator_dict['system_wrapper_keys_select_custodians'],
-                    'value': 'click', 'value_tuple': (admin)}
+                custodian_locator = {
+                    'locator': self.locator_dict['system_wrapper_keys_select_custodians'],
+                    'value': 'click', 'value_tuple': (admin)
+                }
+
                 form_list.append(custodian_locator)
-            form_list.append({'locator': self.locator_dict['apply_btn'], "value":"click"})
+            form_list.append(
+                {'locator': self.locator_dict['apply_btn'], "value": "click"})
             self.go_to_system_wrapper_keys_page()
             self.EF.fill_form(form_list=form_list,
-                                print_info_flag=print_info_flag,
-                                print_exception=print_exception,
-                                clear_element_flag=False)
+                              print_info_flag=print_info_flag,
+                              print_exception=print_exception,
+                              clear_element_flag=False)
 
             if validate_flag:
                 self.go_to_dashboard_page()
                 try:
-                    self.EF.element_click(locator=self.locator_dict['dashboard_management_summary_show_keyshare_click'])
-                    keyshare = self.EF.read_text(locator=self.locator_dict['dashboard_management_summary_show_keyshare_text'])
+                    self.EF.element_click(
+                        locator=self.locator_dict[
+                            'dashboard_management_summary_show_keyshare_click'])
+                    keyshare = self.EF.read_text(
+                        locator=self.locator_dict[
+                            'dashboard_management_summary_show_keyshare_text'])
                 except CE.ElementNotFound:
                     raise CE.ValidateError
             return keyshare
@@ -159,7 +165,6 @@
                         print_info_flag=False,
                         print_exception=True,
                         validate_flag=True):
-
         """Import keyshare using given arguments.
         EP:
             WrapperKeyPage / import keyshare
@@ -174,24 +179,27 @@
         if not keyshare:
             raise CE.ArgumentValueNotProvided
         if by_method.lower() == "rest":
-             raise CE.MethodNotImplemented
+            raise CE.MethodNotImplemented
 
         else:
             form_list = [
-                        {'locator' : self.locator_dict['system_wrapper_keys_operation_ddl'], 'value': 'Import'},
-                        {'locator' : self.locator_dict['add_btn'], 'value': 'button'},
-                        {'locator' : self.locator_dict['system_wrapper_keys_import_keyshare_input'], 'value': keyshare},
-                        {'locator' : self.locator_dict['ok_btn'], 'value': 'click'}]
+                {'locator': self.locator_dict['system_wrapper_keys_operation_ddl'],
+                    'value': 'Import'},
+                {'locator': self.locator_dict['add_btn'], 'value': 'button'},
+                {'locator': self.locator_dict[
+                    'system_wrapper_keys_import_keyshare_input'],
+                    'value': keyshare},
+                {'locator': self.locator_dict['ok_btn'], 'value': 'click'}]
             self.go_to_system_wrapper_keys_page()
             self.EF.fill_form(form_list=form_list,
-                                print_info_flag=print_info_flag,
-                                print_exception=print_exception)
+                              print_info_flag=print_info_flag,
+                              print_exception=print_exception)
         if validate_flag:
             try:
-                key_share_part = "***"+keyshare[-4:]
+                key_share_part = "***" + keyshare[-4:]
                 self.EF.element_click(
-                            locator=self.locator_dict['system_wrapper_keys_select_keyshare'],
-                            value_tuple=(key_share_part))
+                    locator=self.locator_dict['system_wrapper_keys_select_keyshare'],
+                    value_tuple=(key_share_part))
                 self.EF.element_click(locator=self.locator_dict['apply_btn'])
             except Exception as error:
                 RB.print_err(text=error)
Index: Application/DSM/DsmConstants.py
===================================================================
--- Application/DSM/DsmConstants.py	(revision 74135)
+++ Application/DSM/DsmConstants.py	(working copy)
@@ -8,6 +8,7 @@
 
 from os.path import abspath, dirname, join
 import sys
+import os
 
 sys.path.insert(0, abspath(
     join(dirname(__file__), '../../../../../test-cases')))
@@ -15,7 +16,36 @@
 # Dsm original constants Import
 from dsm.constants import *
 
+
 """
+DsmConstants are set based on "execution_by_vaqa" Flag.
+
+If TESTCASE_NAME is present in the environment veriables ,
+then test is being run through VAQA.
+Otherwise through python
+"""
+
+try:
+    _ = os.environ['TEST_CASE_NAME']
+    execution_by_vaqa = True
+except KeyError:
+    execution_by_vaqa = False
+
+
+if execution_by_vaqa:
+    RESTORE_BUILD = os.environ.get('RESTORE_BUILD', '6.0.1.4034')
+    GLOBAL_BY_METHOD = os.environ.get('GLOBAL_BY_METHOD', 'gui')
+    PREREQ_BY_METHOD = os.environ.get('PREREQ_BY_METHOD', 'rest')
+    TEARDOWN_BY_METHOD = os.environ.get('TEARDOWN_BY_METHOD', 'rest')
+
+else:
+    RESTORE_BUILD = "6.0.1.4034"
+    GLOBAL_BY_METHOD = "gui"
+    PREREQ_BY_METHOD = "rest"
+    TEARDOWN_BY_METHOD = "rest"
+
+
+"""
 These are the constants which will be required by Page Object Model
 """
 # Json Locator file path
@@ -28,15 +58,7 @@
 # DSM url and credentials to be used by RESTfull API
 DSM_URL = "https://%s/dsm/v%s" % (DSM, REST_API_VERSION)
 
-# Global By Method
-GLOBAL_BY_METHOD = "gui"
 
-# prerequisites by method
-PREREQ_BY_METHOD = "rest"
-
-# teardown by method
-TEARDOWN_BY_METHOD = "rest"
-
 # Defaul dsm Password
 DEFAULT_DSM_PASSWORD = "Ssl12345#"
 
@@ -56,6 +78,9 @@
 # Global wait time
 GLOBAL_WAIT_TIME = 1
 
+# wait to dsm go down
+GENERAL_WAIT_TIME = 15
+
 # Global random string length
 STRING_LENGTH = 5
 
@@ -86,7 +111,7 @@
 # upgrade file pattern
 upgrade_pattern = 'VORMETRIC_upgrade_version_%s.tar'
 
-#local nfs build path
+# local nfs build path
 local_nfs_build_path = 'unified/server/BUILD_'
 
 # ###   Index for constants ####
@@ -95,7 +120,7 @@
 # 2. Constants required for ssh connection
 # 3. Constants required for generating CA certifications
 # 4. Constants for converting primary to failover
-
+# 5. Contatnts for backup and restore
 #################################
 
 # 1. Timeout constant
@@ -161,3 +186,23 @@
 HA_NETWORK_HSM = "Is the primary Security Server"
 HA_3 = "convert2primary"
 HA_3_RESP = "WARNING"
+
+
+# 5. Contatnts for backup and restore
+
+DSM_BACKUP_NFS_MOUNT_PATH = '10.3.10.45:/vol/vol1_dsmteam'
+LOCAL_BACKUP_PATH_NORMAL = '/root/mnt_dsm_ha_backups'
+LOCAL_BACKUP_PATH_KMIP = '/root/mnt_dsm_ha_backups'
+key_share_1 = '3e6de5ab21e0d2e2e7e5f1505199dd12218d3cccc3a5bd49934a1b16ec4e6fbb'
+key_share_2 = '11dd447a10d5be26ae45e9a73d5f7a3d0088c1b114d08adac78abd4c5fab5012'
+
+# keys are the dsm versions
+# 6 for 6.x.x and 5 for 5.x.x
+NON_KMIP_BACKUP_FILE_PATH = {
+    '6': '/dsm_backups/BU_6.x.x_NoKMIP/',
+    '5': '/asrm-automation/dsm_normal_lic_backups/'
+}
+
+# backup_path_6_x_x_no_KMIP = 'dsm_backups/BU_6.x.x_NoKMIP/'
+# backup_path_5_x_x_no_KMIP = 'asrm-automation/dsm_normal_lic_backups/'
+# extra_backup = 'BU_TEST_DATA/BU_6.x.x_NoKMIP/'
Index: CommonUtilities/UtilityLib.py
===================================================================
--- CommonUtilities/UtilityLib.py	(revision 74135)
+++ CommonUtilities/UtilityLib.py	(working copy)
@@ -1,17 +1,14 @@
 #!/usr/bin/python
+
 # -*- coding: utf-8 -*-
 """
 .. module:: UtilityLib
+   Utility Library :
+           This library includes all general functions
+           for remote as well as local machines.
 """
-
-"""Utility Library
-
-This library includes all general functions for objects
-and test-cases.
-
-"""
-#####  UtilityLib functions #####
-# run_cmd_on_remote_host
+# ####  UtilityLib functions #####
+# run_cmd
 # remove_files_from_server
 # get_latest_downloaded_filepath_from_server
 # get_permission_mode
@@ -26,13 +23,17 @@
 import sys
 import subprocess
 import pexpect
+import hashlib
+import base64
+import glob
+import re
+
+
 try:
     from pexpect import pxssh
 except ImportError:
     import pxssh
 
-import hashlib
-import base64
 try:
     import Crypto
     from Crypto.PublicKey import RSA
@@ -46,13 +47,14 @@
     join(dirname(__file__), '../../../../../test-cases')))
 
 # local lib
+
 from PageObjectModel.CommonUtilities import ReportLib as RB
 from PageObjectModel.CommonUtilities import CustomException as CE
 from PageObjectModel import PageObjectConstants as pom_const
 
+
 def delete_public_keys(ip_list):
     """Delete public keys for given ip addresses
-
     Args:
         ip_list: List of IP adresses
     """
@@ -61,27 +63,10 @@
     for ip in ip_list:
         run_cmd('ssh-keygen -R %s' % ip)
 
-def run_cmd(cmd=''):
-    """Method to execute shell commands
 
-    Args:
-        cmd: Shell command to execute
+def run_cmd(cmd='', server='', user_name='', password=''):
+    """Execute command on server.
 
-    Returns:
-        (return code, standard output, standard error)
-    """
-    if not cmd:
-        raise CE.ArgumentValueNotProvided
-
-    process = subprocess.Popen(cmd, stdout=subprocess.PIPE,
-                   stderr=subprocess.PIPE, shell=True,
-                   env=dict(os.environ, **{'PYTHONIOENCODING':'UTF-8'}))
-    stdout, stderr = process.communicate()
-
-    return process.returncode, stdout, stderr
-
-def run_cmd_on_remote_host(cmd='', server='', user_name='', password=''):
-    """Execute command on server.
     Args:
         server: server ip address
         username: username
@@ -90,6 +75,25 @@
     Return:
         Output of command.
     """
+
+    if not cmd:
+        raise CE.ArgumentValueNotProvided
+
+    if not (server and user_name and password):
+        """
+        if only cmd is given it will excute the command on testmaster.
+        and returns true or false based on the excution
+        """
+        process = subprocess.Popen(cmd, stdout=subprocess.PIPE,
+                                   stderr=subprocess.PIPE, shell=True,
+                                   env=dict(os.environ, **{'PYTHONIOENCODING': 'UTF-8'}))
+        stdout, stderr = process.communicate()
+
+        return process.returncode, stdout, stderr
+
+    """
+    if server details are given then it will run the command on remote server
+    """
     # pxssh connection
     ssh = pxssh.pxssh(timeout=pom_const.SSH_TIMEOUT)
     try:
@@ -110,10 +114,10 @@
     """This method removes file(s) from selenium or other server
 
         Agrs:
-            file_pattern : file(s) to be deleted
-            server : server name or server IP
-            user_name : server username for ssh
-            password : server password for ssh
+            file_pattern: file(s) to be deleted
+            server: server name or server IP
+            user_name: server username for ssh
+            password: server password for ssh
         returns:
             True/False
     """
@@ -123,26 +127,27 @@
     try:
         rm_cmd = 'rm -f %s' % (file_path)
         # execute remove command on server
-        if not run_cmd_on_remote_host(cmd=rm_cmd, server=server,
-                                      user_name=user_name, password=password):
+        if not run_cmd(cmd=rm_cmd, server=server,
+                       user_name=user_name, password=password):
             return False
     except Exception as error:
         RB.print_err(text=error)
         return False
     return True
 
+
 def copy_files_from_server(remote_file_path='',
                            local_file_path="",
                            server='', user_name='', password=''):
     """This method copies file from selenium or other server
 
         Agrs:
-            remote_file_path : file to be copied
-            local_file_path : file name on
+            remote_file_path: file to be copied
+            local_file_path: file name on
                 the local machine where to copy the file
-            server : server name or server IP
-            user_name : server username for ssh
-            password : server password for ssh
+            server: server name or server IP
+            user_name: server username for ssh
+            password: server password for ssh
         returns:
             True/False
     """
@@ -150,22 +155,25 @@
         raise CE.ArgumentValueNotProvided
 
     try:
-        copy_cmd = "scp %s@%s:%s %s"%(user_name,
-                                      server,
-                                      remote_file_path,
-                                      local_file_path)
+        copy_cmd = "scp %s@%s:%s %s" % (user_name,
+                                        server,
+                                        remote_file_path,
+                                        local_file_path)
         child = pexpect.spawn(copy_cmd)
-        index = child.expect([pom_const.RESP1, pom_const.RESP2, pom_const.RESP3])
+        index = child.expect(
+            [pom_const.RESP1, pom_const.RESP2, pom_const.RESP3])
         if index == 0:
             child.sendline('yes')
-            child.expect(user_name + "@" + server + ".*", timeout=pom_const.SSH_TIMEOUT)
+            child.expect(user_name + "@" + server + ".*",
+                         timeout=pom_const.SSH_TIMEOUT)
         elif index == 2:
-            RB.print_err(text="ssh: connect to %s port 22: Connection refused"%server)
+            RB.print_err(
+                text="ssh: connect to %s port 22: Connection refused" % server)
             child.close()
             raise CE.ConnectionRefusedError
 
         child.sendline(password)
-        #child.expect("*" + remote_file_path.split("/")[-1] + "*")
+        # child.expect("*" + remote_file_path.split("/")[-1] + "*")
         child.close()
         return os.path.isfile(local_file_path)
     except Exception as error:
@@ -180,10 +188,10 @@
     """This method gives latest downloaded file path from selenium or other server
 
         Agrs:
-            download_dir : Directory contains downloaded file
-            server : server name or server IP
-            user_name : server username for ssh
-            password : server password for ssh
+            download_dir: Directory contains downloaded file
+            server: server name or server IP
+            user_name: server username for ssh
+            password: server password for ssh
         returns:
             File Path of the downloaded file or None
     """
@@ -194,24 +202,27 @@
         getfile_cmd = 'ls -t %s|head -1' % (download_dir)
         # execute command on server
 
-        output = run_cmd_on_remote_host(
+        output = run_cmd(
             cmd=getfile_cmd, server=server, user_name=user_name, password=password)
         if "No such file or directory" in output:
+            print " Here"
             return None
         return output
+
     except Exception as error:
         RB.print_err(text=error)
         return None
 
+
 def get_permission_mode(args_dict={}):
     """This method gets the file permission from a remote machine
 
         Agrs:
             {
-                host : remote machine ip of which file permissions are needed
-                user_name : server username for ssh
-                password : server password for ssh
-                file_path : absolute path of the file of which permissions are needed
+                host: remote machine ip of which file permissions are needed
+                user_name: server username for ssh
+                password: server password for ssh
+                file_path: absolute path of the file of which permissions are needed
             }
         returns:
             File permission in integer form if File exists
@@ -224,50 +235,50 @@
     username = args_dict['username']
     password = args_dict['password']
     file_path_list = []
-    file_type = ""
 
-    cmd = "stat %s"%args_dict['file_path']
-    file_attr = run_cmd_on_remote_host(cmd=cmd,
-                                       server=server,
-                                       user_name=username,
-                                       password=password).splitlines()#[1].split()[-1]
+    cmd = "stat %s" % args_dict['file_path']
+    file_attr = run_cmd(cmd=cmd,
+                        server=server,
+                        user_name=username,
+                        password=password).splitlines()  # [1].split()[-1]
     if any("Size" in attr for attr in file_attr) and \
-    any("regular file" in attr for attr in file_attr):
+            any("regular file" in attr for attr in file_attr):
         file_path_list.append(args_dict['file_path'])
     if any("Size" in attr for attr in file_attr) and \
-    any("directory" in attr for attr in file_attr):
-        cmd = "ls %s"%args_dict['file_path']
-        files_list = run_cmd_on_remote_host(cmd=cmd,
-                                            server=server,
-                                            user_name=username,
-                                            password=password)
+            any("directory" in attr for attr in file_attr):
+        cmd = "ls %s" % args_dict['file_path']
+        files_list = run_cmd(cmd=cmd,
+                             server=server,
+                             user_name=username,
+                             password=password)
         files_list = files_list.splitlines()
         for files in files_list:
             file_path_list.append(args_dict['file_path'] + "/" + files)
 
     file_path_dict = dict((el, None) for el in file_path_list)
     for file_path in file_path_dict.keys():
-        cmd = "stat --format '%%a' %s"%file_path
-        file_mode = run_cmd_on_remote_host(cmd=cmd,
-                                           server=server,
-                                           user_name=username,
-                                           password=password).splitlines()[2]
+        cmd = "stat --format '%%a' %s" % file_path
+        file_mode = run_cmd(cmd=cmd,
+                            server=server,
+                            user_name=username,
+                            password=password).splitlines()[2]
         file_path_dict[file_path] = int(file_mode)
 
     if len(file_path_dict.values()) > 0:
-        return sum( map(int, file_path_dict.values()))/len(file_path_dict.values())
+        return sum(map(int, file_path_dict.values())) / len(file_path_dict.values())
     else:
         return False
 
+
 def change_permission_mode(args_dict={}):
     """This method change the file permission on a remote machine
 
         Agrs:
             {
-                host : remote machine ip of which file permissions are to be changed
-                user_name : server username for ssh
-                password : server password for ssh
-                file_path : absolute path of the file of which permissions are to be changed
+                host: remote machine ip of which file permissions are to be changed
+                user_name: server username for ssh
+                password: server password for ssh
+                file_path: absolute path of the file of which permissions to be changed
             }
         returns:
             True/False
@@ -278,23 +289,22 @@
     username = args_dict['username']
     password = args_dict['password']
     file_path_list = []
-    file_type = ""
 
-    cmd = "stat %s"%args_dict['file_path']
-    file_attr = run_cmd_on_remote_host(cmd=cmd,
-                                       server=server,
-                                       user_name=username,
-                                       password=password).splitlines()
+    cmd = "stat %s" % args_dict['file_path']
+    file_attr = run_cmd(cmd=cmd,
+                        server=server,
+                        user_name=username,
+                        password=password).splitlines()
     if any("Size" in attr for attr in file_attr) and \
-    any("regular file" in attr for attr in file_attr):
+            any("regular file" in attr for attr in file_attr):
         file_path_list.append(args_dict['file_path'])
     elif any("Size" in attr for attr in file_attr) and \
-    any("directory" in attr for attr in file_attr):
-        cmd = "ls %s"%args_dict['file_path']
-        files_list = run_cmd_on_remote_host(cmd=cmd,
-                                            server=server,
-                                            user_name=username,
-                                            password=password)
+            any("directory" in attr for attr in file_attr):
+        cmd = "ls %s" % args_dict['file_path']
+        files_list = run_cmd(cmd=cmd,
+                             server=server,
+                             user_name=username,
+                             password=password)
         files_list = files_list.splitlines()
         for files in files_list:
             file_path_list.append(args_dict['file_path'] + "/" + files)
@@ -304,11 +314,11 @@
     file_path_dict = dict((el, None) for el in file_path_list)
 
     for file_path in file_path_dict.keys():
-        cmd = 'chmod %d %s'%(args_dict['permissions'], file_path)
-        run_cmd_on_remote_host(cmd=cmd,
-                               server=server,
-                               user_name=username,
-                               password=password)
+        cmd = 'chmod %d %s' % (args_dict['permissions'], file_path)
+        run_cmd(cmd=cmd,
+                server=server,
+                user_name=username,
+                password=password)
 
     for file_path in file_path_dict.keys():
         new_args_dict = args_dict
@@ -322,17 +332,18 @@
     else:
         return True
 
+
 def enable_vmsupport(args_dict={}):
     """This method gives root access to a virtual machine
 
         Agrs:
             {
-                server : remote machine ip on which vmsupport script resides
-                user_name : server username for ssh
-                password : server password for ssh
-                script_dir : directory in which the vmsuppport script resides
-                script_file : name of the vmsupport script file
-                host : ip of the virtual machine
+                server: remote machine ip on which vmsupport script resides
+                user_name: server username for ssh
+                password: server password for ssh
+                script_dir: directory in which the vmsuppport script resides
+                script_file: name of the vmsupport script file
+                host: ip of the virtual machine
             }
         returns:
             True/False
@@ -346,74 +357,76 @@
     script_dir = args_dict['script_dir']
     script_file = args_dict['script_file']
     vm_machine = args_dict['host']
-    cmd = "cd %s && ./%s %s"%(script_dir,
-                              script_file,
-                              vm_machine)
-    result = run_cmd_on_remote_host(cmd=cmd,
-                                    server=server,
-                                    user_name=username,
-                                    password=password).splitlines()
+    cmd = "cd %s && ./%s %s" % (script_dir,
+                                script_file,
+                                vm_machine)
+    result = run_cmd(cmd=cmd,
+                     server=server,
+                     user_name=username,
+                     password=password).splitlines()
     if any("Success." in msg for msg in result):
         return True
     else:
         return False
 
+
 def mount_cmd(mount_src='', mount_dst='', server_dict={}):
     """mount command mounts filesystem or stroage device
         to existing directory structure
-    Args :
-            mount_src : source filesystem to be mounted
-            mount_dst : destination filesystem
-            Note : To run mount command on remote server
-            server_dict = { server : server ip or name
-                            user_name : server userr name
-                            password : server password
+    Args:
+            mount_src: source filesystem to be mounted
+            mount_dst: destination filesystem
+            Note: To run mount command on remote server
+            server_dict = {server: server ip or name
+                            user_name: server userr name
+                            password: server password
                           }
     Returns:
         Boolean
     """
-    if not mount_src and not mount_dst :
+    if not mount_src and not mount_dst:
         raise CE.ArgumentValueNotProvided
 
-    mkdir_cmd = "mkdir -p %s" %mount_dst
-    mnt_cmd =  "mount -o ro %s %s" %(mount_src, mount_dst)
+    mkdir_cmd = "mkdir -p %s" % mount_dst
+    mnt_cmd = "mount -o ro %s %s" % (mount_src, mount_dst)
     if server_dict:
-        #create directory
-        output = run_cmd_on_remote_host(cmd=mkdir_cmd,
-                                        server=server_dict['server'],
-                                        user_name=server_dict['user_name'],
-                                        password=server_dict['password'])
-        #mount a filesystem
-        output = run_cmd_on_remote_host(cmd=mnt_cmd,
-                                        server=server_dict['server'],
-                                        user_name=server_dict['user_name'],
-                                        password=server_dict['password'])
+        # create directory
+        output = run_cmd(cmd=mkdir_cmd,
+                         server=server_dict['server'],
+                         user_name=server_dict['user_name'],
+                         password=server_dict['password'])
+        # mount a filesystem
+        output = run_cmd(cmd=mnt_cmd,
+                         server=server_dict['server'],
+                         user_name=server_dict['user_name'],
+                         password=server_dict['password'])
         if output:
             RB.print_debug(text=output)
             RB.print_err(text="Mount operation on remote server[%s] failed"
-                        %server_dict)
+                         % server_dict)
             return False
         return True
     else:
-        #create directory
+        # create directory
         ret_code, stdout, stderr = run_cmd(cmd=mkdir_cmd)
-        #mount a filesystem
+        # mount a filesystem
         ret_code, stdout, stderr = run_cmd(cmd=mnt_cmd)
         if ret_code:
             RB.print_err(text="Mount operation failed")
-            RB.print_debug(text="STDOUT : %s" %stdout)
-            RB.print_debug(text="STDERR : %s" %stderr)
+            RB.print_debug(text="STDOUT : %s" % stdout)
+            RB.print_debug(text="STDERR : %s" % stderr)
             return False
         return True
 
+
 def umount_cmd(umount_dir='', server_dict={}):
     """umount command unmount filesystem
-    Args :
-            umount_dir : Directory structure to be unmounted
-            Note : To run mount command on remote server
-            server_dict = { server : server ip or name
-                            user_name : server userr name
-                            password : server password
+    Args:
+            umount_dir: Directory structure to be unmounted
+            Note: To run mount command on remote server
+            server_dict = {server: server ip or name
+                            user_name: server userr name
+                            password: server password
                           }
     Returns:
         Boolean
@@ -421,31 +434,32 @@
     if not umount_dir and not server_dict:
         raise CE.ArgumentValueNotProvided
 
-    umnt_cmd =  "umount %s" %(umount_dir)
+    umnt_cmd = "umount %s" % (umount_dir)
     if server_dict:
-        #umount a filesystem
-        output = run_cmd_on_remote_host(cmd=umnt_cmd,
-                                        server=server_dict['server'],
-                                        user_name=server_dict['user_name'],
-                                        password=server_dict['password'])
+        # umount a filesystem
+        output = run_cmd(cmd=umnt_cmd,
+                         server=server_dict['server'],
+                         user_name=server_dict['user_name'],
+                         password=server_dict['password'])
         if output:
             RB.print_debug(text=output)
             RB.print_err(text="Umount operation on remote server[%s] failed"
-                                        %server_dict)
+                         % server_dict)
             return False
         return True
     else:
-        #umount a filesystem
+        # umount a filesystem
         ret_code, stdout, stderr = run_cmd(cmd=umnt_cmd)
         if ret_code:
             RB.print_err(text="Umount operation failed")
-            RB.print_debug(text="STDOUT : %s" %stdout)
-            RB.print_debug(text="STDERR : %s" %stderr)
+            RB.print_debug(text="STDOUT : %s" % stdout)
+            RB.print_debug(text="STDERR : %s" % stderr)
             return False
         return True
 
+
 def wrap_key(passphrase, public_key, hashAlgo=None, mgfunc=None):
-    """ Wrap a key with DSM wrapping (asymmetric) key."""
+    """ Wrap a key with DSM wrapping(asymmetric) key."""
     if hashAlgo is None:
         hashAlgo = Crypto.Hash.SHA256
     sym_key = hashlib.sha256(passphrase).digest()
@@ -454,3 +468,14 @@
     secret = cipher.encrypt(sym_key)
     bsecret = base64.b64encode(secret)
     return bsecret
+
+
+def get_file_from_local_machine(dir_path='', file_patern=''):
+    """ Find file/s in given directory and return list using given pattern"""
+    RB.print_info(text="Path for get the backup file is %s" % dir_path)
+    reg = re.compile(file_patern)
+    file_list = []
+    for file_name in glob.glob(dir_path):
+        if reg.search(file_name):
+            file_list.append(file_name)
+    return file_list
Index: PageObjectConstants.py
===================================================================
--- PageObjectConstants.py	(revision 74135)
+++ PageObjectConstants.py	(working copy)
@@ -12,16 +12,18 @@
 
 
 REMOTE_CONFIGURATION = {
-    'SELENIUM_SERVER': "10.10.68.190",
-#     'SELENIUM_SERVER': "10.10.68.189",
-     'BROWSER_NAME': "chrome",
-     'BROWSER_VERSION': "",
-     'SELENIUM_SERVER_USER_NAME': "Administrator",
-     'SELENIUM_SERVER_PASSWORD': "Ssl12345#",
+    # 'SELENIUM_SERVER': "10.10.68.190",
+    'SELENIUM_SERVER': "10.10.68.191",
+    'BROWSER_NAME': "chrome",
+    'BROWSER_VERSION': "",
+    'SELENIUM_SERVER_USER_NAME': "tester",
+    'SELENIUM_SERVER_PASSWORD': "ssl12345",
+    # 'SELENIUM_SERVER_USER_NAME': "Administrator",
+    # 'SELENIUM_SERVER_PASSWORD': "Ssl12345#",
     'SELENIUM_SERVER_PORT': "5555",
-#     'SELENIUM_SERVER_PORT': "4444",
-     'EXECUTION_TYPE': "REMOTE",
-     'SERVER_OS': "windows"
+    'EXECUTION_TYPE': "REMOTE",
+    #     'SELENIUM_SERVER': "10.10.68.189",
+    'SERVER_OS': "linux"
 }
 
 BROWSER_STACK_CONFIGURATION = {
@@ -40,18 +42,21 @@
 
 # download directory
 if WebDriverDict['SERVER_OS'] == "windows":
-    DOWNLOAD_DIR = "/cygdrive/c/Users/%s/Downloads/"%WebDriverDict['SELENIUM_SERVER_USER_NAME']
+    DOWNLOAD_DIR = "/cygdrive/c/Users/%s/Downloads/" % (
+        WebDriverDict['SELENIUM_SERVER_USER_NAME'])
 else:
     DOWNLOAD_DIR = "~/Downloads/"
+    ABSOLUTE_DOWNLOAD_DIR = "/home/tester/Downloads/"
 
-
-VM_SUPPORT_SCRIPT_SERVER = os.getenv("VM_SUPPORT_SCRIPT_SERVER", "10.10.65.149")
-VM_SUPPORT_SCRIPT_SERVER_USERNAME = os.getenv("VM_SUPPORT_SCRIPT_SERVER_USERNAME", "root")
-VM_SUPPORT_SCRIPT_SERVER_PASSWORD = os.getenv("VM_SUPPORT_SCRIPT_SERVER_PASSWORD", "ssl12345")
+VM_SUPPORT_SCRIPT_SERVER = os.getenv(
+    "VM_SUPPORT_SCRIPT_SERVER", "10.10.65.149")
+VM_SUPPORT_SCRIPT_SERVER_USERNAME = os.getenv(
+    "VM_SUPPORT_SCRIPT_SERVER_USERNAME", "root")
+VM_SUPPORT_SCRIPT_SERVER_PASSWORD = os.getenv(
+    "VM_SUPPORT_SCRIPT_SERVER_PASSWORD", "ssl12345")
 VM_SUPPORT_SCRIPT_DIR = os.getenv("VM_SUPPORT_SCRIPT_DIR", "/root/vmsupport2")
 VM_SUPPORT_SCRIPT_FILE = os.getenv("VM_SUPPORT_SCRIPT_FILE", "vmsupport2")
 
 LOCAL_BROWSER_BINARY_LOCATION = "/Applications/chrome.app/Contents/MacOS/Google Chrome"
 
-# timeout for ssh
-SSH_TIMEOUT = 30
+SSH_TIMEOUT = 10
Index: Tests/DSM/AdminPage/create_admin.py
===================================================================
--- Tests/DSM/AdminPage/create_admin.py	(revision 74135)
+++ Tests/DSM/AdminPage/create_admin.py	(working copy)
@@ -1,79 +0,0 @@
-#!/usr/bin/python
-
-###################################################
-# Create admins                                   #
-# EP : AdminPage / create admin                  #
-#      AdminPage / delete admin                  #
-#                                                 #
-# This testcase is for testing creation of admins #
-###################################################
-
-
-# Standard python library
-import unittest
-import sys
-from os.path import abspath, dirname, join
-
-# Update System path
-sys.path.insert(0, abspath(
-    join(dirname(__file__), '../../../../../test-cases')))
-
-# Rest Imports
-from dsm.rest.library import misclib as MiscLib
-
-# Framework library modules
-from PageObjectModel.Application.DSM.DSMPages.LoginPage import LoginPage
-from PageObjectModel.Application.DSM.DSMPages.AdminPage import AdminPage
-from PageObjectModel.Application.DSM import DsmConstants as dsm_const
-from PageObjectModel.WebDriverUtility.GetWebDriver import GetWebDriver
-from PageObjectModel.CommonUtilities import ReportLib as RB
-from PageObjectModel.PageObjectConstants import WebDriverDict
-
-
-# admin_dict  =  {"name" : "test_admin", --strictly required
-#               "description" : "desc",
-#               "rsa_user_id" : "id",
-#               "password" : "Password for admin", --strictly required
-#               "confirm_password" : "re-center password",
-#               "user_type" : "system/ domain/ security/ all",
-#               "read_only_user" : "True / False"
-# }
-
-admin_dict = {
-    'name': "Admin" + MiscLib.generate_mix_normal_string(dsm_const.STRING_LENGTH),
-    'password': dsm_const.DEFAULT_INITIAL_PASSWORD,
-    'adminType': dsm_const.DEFAULT_ADMIN_ROLE,
-    'description': "DESC",
-    'readOnly': False
-}
-
-
-class create_admin(unittest.TestCase):
-
-    def __init__(self, testname=None, values=None):
-        super(create_admin, self).__init__(testname)
-        self.values = values
-
-    def setUp(self):
-        self.driver = GetWebDriver(WebDriverDict).Driver
-        self.driver.maximize_window()
-        """Creating objects of required pages."""
-        self.login_page_object = LoginPage(self.driver)
-        self.admin_page_object = AdminPage(self.driver)
-        self.login_page_object.login()
-
-    def test_01_create_admin_by_gui(self):
-        self.admin_page_object.create_admin(
-            admin_dict=admin_dict)
-
-    def test_02_delete_admin_by_gui(self):
-        self.admin_page_object.delete_admin(
-            admin_name=admin_dict['name'])
-
-    def tearDown(self):
-        self.login_page_object.logout()
-        self.driver.quit()
-
-
-if __name__ == "__main__":
-    unittest.main()
Index: Tests/DSM/AdminPage/testlist
===================================================================
--- Tests/DSM/AdminPage/testlist	(revision 74135)
+++ Tests/DSM/AdminPage/testlist	(working copy)
@@ -1,4 +1,5 @@
 test_CreateDeleteAdmin.py
 test_EditAdminDetails.py
 test_AddRemoveAdminFromDomain.py
-test_EnableDisableAdmin.py
\ No newline at end of file
+test_EnableDisableAdmin.py
+test_ExportAllAdmins.py
\ No newline at end of file
Index: UseCases/DSM/TestLink/BackupRestore/test_BackupRestore.py
===================================================================
--- UseCases/DSM/TestLink/BackupRestore/test_BackupRestore.py	(revision 0)
+++ UseCases/DSM/TestLink/BackupRestore/test_BackupRestore.py	(working copy)
@@ -0,0 +1,460 @@
+
+##################################################################
+# Backup Restore                                                 #
+# EP:                                                            #
+#                                                                #
+# This use-case is to check backup restore operations from 6.0.1 #
+# with failover server setup                                     #
+##################################################################
+
+
+# standard python library
+import unittest
+import sys
+import time
+import datetime
+import traceback
+from collections import OrderedDict
+from os.path import abspath, dirname, join
+
+# Update System path
+sys.path.insert(0, abspath(
+    join(dirname(__file__), '../../../../../../test-cases')))
+
+# Rest frameork import
+from dsm.rest.library import misclib as MiscLib
+
+
+# Framework library modules
+from PageObjectModel import PageObjectConstants as pom_const
+from PageObjectModel.PageObjectConstants import WebDriverDict
+from PageObjectModel.WebDriverUtility.GetWebDriver import GetWebDriver
+
+from PageObjectModel.CommonUtilities import ReportLib as RB
+from PageObjectModel.CommonUtilities import UtilityLib as UtilLib
+
+from PageObjectModel.Application.DSM.DSMLibrary import CliModule as cli_mod
+from PageObjectModel.Application.DSM.DSMLibrary import DsmModule as dsm_mod
+
+
+from PageObjectModel.Application.DSM import DsmConstants as dsm_const
+from PageObjectModel.Application.DSM.DSMPages.LoginPage import LoginPage
+from PageObjectModel.Application.DSM.DSMPages.AdminPage import AdminPage
+from PageObjectModel.Application.DSM.DSMPages.DomainPage import DomainPage
+from PageObjectModel.Application.DSM.DSMPages.BackupRestore import BackupRestorePage
+from PageObjectModel.Application.DSM.DSMPages.WrapperKeyPage import WrapperKeyPage
+from PageObjectModel.Application.DSM.DSMPages.HostPage import HostPage
+from PageObjectModel.Application.DSM.DSMPages.PoliciesPage import PoliciesPage
+from PageObjectModel.Application.DSM.DSMPages.KeyPage import KeyPage
+from PageObjectModel.Application.DSM.DSMPages.\
+    HighAvailabilityPage import HighAvailabilityPage
+
+# admin dict
+admin_dict = {
+    'name': "voradmin",
+    'password': dsm_const.DEFAULT_INITIAL_PASSWORD,
+    'adminType': dsm_const.DEFAULT_ADMIN_ROLE,
+    'description': "backup restore admin_role",
+    'readOnly': False
+}
+
+# domain dict
+domain_dict = {
+    "name": "domain1",
+    "description": "backup restore domain"
+}
+
+# host dict
+host_dict = OrderedDict()
+host_dict["name"] = dsm_const.AGENT_HOSTNAME
+host_dict["desc"] = "dsm603"
+host_dict["VTE"] = True
+host_dict["enabled"] = True
+
+# server credentials
+server_dict = {
+    'download_dir': pom_const.ABSOLUTE_DOWNLOAD_DIR,
+    'server': WebDriverDict['SELENIUM_SERVER'],
+    'user_name': WebDriverDict['SELENIUM_SERVER_USER_NAME'],
+    'password': WebDriverDict['SELENIUM_SERVER_PASSWORD'],
+}
+
+# expiry date
+st = datetime.datetime.fromtimestamp(time.time()) +\
+    datetime.timedelta(days=3)
+expiration_date = st.strftime("%m/%d/%Y")
+# key dict
+key_dict = OrderedDict()
+key_dict['name'] = "backup_restore_key_" +\
+                   MiscLib.generate_mix_normal_string(
+                       length=dsm_const.STRING_LENGTH)
+key_dict['key_type'] = 'symmetric'
+key_dict['algo'] = 'AES128'
+key_dict['expiry_date'] = expiration_date
+key_dict['Key_rotation'] = False
+
+# policy dict
+policy_dict = OrderedDict()
+policy_dict['name'] = 'backup_restore_' +\
+    MiscLib.generate_mix_normal_string(length=dsm_const.STRING_LENGTH)
+policy_dict['policy_type'] = 'Standard'
+policy_dict['keyname'] = key_dict['name']
+
+
+# guard_point_dict
+guardpoint_dict = OrderedDict()
+guardpoint_dict['host_name'] = host_dict["name"]
+guardpoint_dict['policy'] = policy_dict['name']
+guardpoint_dict['type'] = 'Directory (Auto Guard)'
+guardpoint_dict['path'] = dsm_const.GUARD_PATH
+
+file_info_dict = {
+    "build_number": dsm_const.RESTORE_BUILD[:5],
+    "build_version": dsm_const.RESTORE_BUILD[6:],
+    "file_type": '.tar'
+}
+
+
+class BackupRestore(unittest.TestCase):
+
+    def __init__(self, testname=None, values=None):
+        super(BackupRestore, self).__init__(testname)
+        self.values = values
+        self.driver = GetWebDriver(WebDriverDict).Driver
+        self.driver.maximize_window()
+
+    def setUp(self):
+        """Creating objects of required pages."""
+        self.login_page_obj = LoginPage(self.driver)
+        self.admin_page_obj = AdminPage(self.driver)
+        self.domain_page_obj = DomainPage(self.driver)
+        self.backup_restore_page_object = BackupRestorePage(self.driver)
+        self.wrapperkey_page_object = WrapperKeyPage(self.driver)
+        self.ha_page_obj = HighAvailabilityPage(self.driver)
+        self.policy_page_obj = PoliciesPage(self.driver)
+        self.key_page_obj = KeyPage(self.driver)
+        self.host_page_obj = HostPage(self.driver)
+
+    def test_backup_restore(self):
+        try:
+
+            """ Step 1. Login to dsm with domain admin """
+            self.login_page_obj.login(user_name=admin_dict['name'],
+                                      validate_login=False,
+                                      print_exception=False)
+
+            """ Step 2. Login to dsm with domain admin """
+            self.wrapperkey_page_object.import_keyshare(
+                keyshare=dsm_const.key_share_1)
+            try:
+                self.EF.handle_alert()
+            except Exception:
+                pass
+
+            self.login_page_obj.go_to_dashboard_page()
+
+            RB.print_info(text="Wrapper key imported successfully.")
+
+            """ Step 3. Mounting DSM backup repo on testmaster """
+            if UtilLib.mount_cmd(mount_src=dsm_const.DSM_BACKUP_NFS_MOUNT_PATH,
+                                 mount_dst=dsm_const.LOCAL_BACKUP_PATH_NORMAL):
+                RB.print_info("DSM backup repo mounted successfully")
+            else:
+
+                UtilLib.umount_cmd(
+                    umount_dir=dsm_const.LOCAL_BACKUP_PATH_NORMAL)
+
+                UtilLib.mount_cmd(mount_src=dsm_const.DSM_BACKUP_NFS_MOUNT_PATH,
+                                  mount_dst=dsm_const.LOCAL_BACKUP_PATH_NORMAL)
+
+                RB.print_info("DSM backup repo mounted successfully")
+
+            """ Step 4. getting backup file from the build server """
+            backup_file_path = dsm_mod.get_backup_file_path(
+                file_info_dict=file_info_dict,
+                mount_dir_path=dsm_const.LOCAL_BACKUP_PATH_NORMAL)
+
+            RB.print_info(
+                text="Backup file for build [%s] is [%s]" % (
+                    file_info_dict['build_number'], backup_file_path))
+
+            """ Step 5. restore backup file and it on DSM and do genca """
+            if self.backup_restore_page_object.restore_backup_file(
+                    backup_file_path=backup_file_path):
+                RB.print_info(
+                    "Backup file [ %s] restored successfully." % backup_file_path)
+
+            cli_mod.genca()
+            self.login_page_obj.wait_for_login_page()
+
+            RB.print_info(
+                text="Certificate is generated for the dsm hostname successfully.")
+
+            """ Step 6. Login to dsm with restored backup and switch domain """
+            self.login_page_obj.login(user_name=admin_dict['name'],
+                                      validate_login=False,
+                                      print_exception=False)
+
+            self.domain_page_obj.switch_into_a_domain(
+                domain_name=domain_dict['name'])
+
+            # create key
+            self.key_page_obj.add_key(key_dict_list=[key_dict],
+                                      domain_name=domain_dict['name'])
+            RB.print_info(text="Symmetric key[%s] added "
+                          " successfully.\n" % key_dict['name'])
+
+            # create policy
+            self.policy_page_obj.add_policy(policy_dict=policy_dict)
+            RB.print_info(
+                text="Policy [%s] added successfully.\n" % policy_dict['name'])
+
+            """ Step 7. Add host on gui with install and register host"""
+            self.host_page_obj.add_host(host_dict,
+                                        domain_name=domain_dict['name'],
+                                        user_name=admin_dict['name'],
+                                        install_register_flag=True)
+            RB.print_info(text="Host [%s] added successfully.\n"
+                          % host_dict['name'])
+
+            """ Step 8. Add guard point by creating directory on agent host."""
+            UtilLib.run_cmd(cmd='mkdir -p %s' % dsm_const.GUARD_PATH,
+                            server=dsm_const.AGENT_HOSTNAME,
+                            user_name=dsm_const.AGENT_USERNAME,
+                            password=dsm_const.AGENT_PASSWORD)
+
+            RB.print_info(text="Directory[%s] created successfully on agent[%s].\n"
+                          % (dsm_const.GUARD_PATH, dsm_const.AGENT_HOSTNAME))
+
+            self.host_page_obj.add_guardpoint_to_host(
+                guardpoint_dict=guardpoint_dict)
+
+            RB.print_info(text="Guardpoint[%s] added to Host [%s] successful.\n"
+                          % (guardpoint_dict['path'], guardpoint_dict['host_name']))
+
+            """ Step 9. Check guard point status."""
+            self.host_page_obj.check_guardpoint_status(host_name=host_dict['name'],
+                                                       guard_path=guardpoint_dict['path'])
+
+            RB.print_info(text="Guardpoint[%s] is up and running at the VTE host[%s]\n"
+                          % (guardpoint_dict['path'], host_dict['name']))
+
+            self.domain_page_obj.exit_from_a_domain()
+            RB.print_info(
+                text="Successfully exited domain[%s].\n" % domain_dict['name'])
+
+            """ Step 10. Add HA by adding failover entryto primary DSM."""
+            RB.print_info(text="Setup HA in progress...\n")
+
+            self.ha_page_obj.add_ha(failover=dsm_const.FAILOVER_HOSTNAME)
+
+            RB.print_info(
+                text="Failover[%s] entry added successfully\n" %
+                dsm_const.FAILOVER_HOSTNAME)
+
+            """ Step 11. Convert to failover"""
+            if cli_mod.convert_to_failover(
+                primary_server=dsm_const.DSM_HOSTNAME,
+                    failover_server=dsm_const.FAILOVER_HOSTNAME,
+                    primary_admin_name=admin_dict['name'],
+                    primary_admin_pass=dsm_const.DEFAULT_DSM_PASSWORD):
+
+                RB.print_info(
+                    text="Server[%s] successfully converted to failover.\n" %
+                    dsm_const.FAILOVER_HOSTNAME)
+
+            else:
+                RB.print_err(
+                    text="Failed to convert server[%s] to failover\n" %
+                    dsm_const.FAILOVER_HOSTNAME)
+                sys.exit(1)
+
+            """ Step 12. Config replication in failover entry"""
+            self.ha_page_obj.config_replication_ha(
+                failover=dsm_const.FAILOVER_HOSTNAME)
+            RB.print_info(
+                text="HA config replication for failover entry[%s] is successful\n" %
+                dsm_const.FAILOVER_HOSTNAME)
+
+            """ Step 13. Get total count for domains, admins and other security objects"""
+            count_dict = OrderedDict()
+            count_dict['domain_count'] = self.domain_page_obj.total_domain_count()
+            count_dict['admin_count'] = self.admin_page_obj.total_admin_count()
+            self.domain_page_obj.switch_into_a_domain(
+                domain_name=domain_dict['name'])
+            count_dict['key_count'] = self.key_page_obj.total_key_count()
+            count_dict['host_count'] = self.host_page_obj.total_host_count()
+            count_dict['policy_count'] = self.policy_page_obj.total_policies_count()
+            self.domain_page_obj.exit_from_a_domain()
+            RB.print_info(
+                text="Successfully exited domain[%s].\n" % domain_dict['name'])
+
+            """ Step 14. Get backup  file from manual backup of primary DSM."""
+            latest_backup_file = self.backup_restore_page_object.manual_backup(
+                server_dict=server_dict)
+
+            """ Step 15. Break HA (cleanup replication)"""
+            self.ha_page_obj.cleanup_replication_ha(
+                failover=dsm_const.FAILOVER_HOSTNAME)
+
+            RB.print_info(
+                text="HA cleanup for failover entry[%s] is successful\n" %
+                dsm_const.FAILOVER_HOSTNAME)
+
+            """ Step 16. Delete HA"""
+            self.ha_page_obj.delete_ha(
+                failover_list=[dsm_const.FAILOVER_HOSTNAME])
+
+            RB.print_info(
+                text="Failover entry[%s] deleted successfully\n" %
+                dsm_const.FAILOVER_HOSTNAME)
+
+            """ Step 17. Convert to primary server"""
+            if cli_mod.convert_to_primary(server=dsm_const.FAILOVER_HOSTNAME):
+                RB.print_info(
+                    text="Server[%s] successfully converted to primary server.\n" %
+                    dsm_const.FAILOVER_HOSTNAME)
+            else:
+                RB.print_err(
+                    text="Failed to convert server[%s] to primary\n" %
+                    dsm_const.FAILOVER_HOSTNAME)
+                sys.exit(1)
+
+            self.login_page_obj.logout()
+
+            self.login_page_obj.login(user_name=admin_dict['name'],
+                                      dsm_url=dsm_const.FAILOVER_HOSTNAME,
+                                      validate_login=False,
+                                      print_exception=False)
+
+            """ Step 18. Add wrapper key to Second DSM"""
+            self.wrapperkey_page_object.import_keyshare(
+                keyshare=dsm_const.key_share_1, validate_flag=False)
+            RB.print_info(text="Wrapper key imported successfully.")
+
+            self.login_page_obj.go_to_dashboard_page()
+
+            if self.backup_restore_page_object.restore_backup_file(
+                    backup_file_path=latest_backup_file,
+                    dsm_host_name=dsm_const.FAILOVER):
+                RB.print_info(
+                    "Backup file [ %s] restored successfully." % latest_backup_file)
+
+            else:
+                RB.print_err(
+                    "Backup file [ %s] restoration failed." % latest_backup_file)
+                sys.exit(1)
+
+            """ create dsm url for failover dsm"""
+            failover_dsm_url = "https://%s/dsm/v%s" % (dsm_const.FAILOVER,
+                                                       dsm_const.REST_API_VERSION)
+
+            """ Step 19. Generate certificate on failover DSM """
+            cli_mod.genca(failover_dsm_url, dsm_const.FAILOVER_HOSTNAME)
+            self.login_page_obj.wait_for_login_page(
+                dsm_host_name=dsm_const.FAILOVER)
+
+            self.login_page_obj.login(user_name=admin_dict['name'],
+                                      dsm_url=dsm_const.FAILOVER_HOSTNAME,
+                                      validate_login=False,
+                                      print_exception=False)
+
+            """Step 20. Add failover entry"""
+            self.ha_page_obj.add_ha(failover=dsm_const.DSM_HOSTNAME)
+            RB.print_info(text="Failover[%s] entry added successfully\n"
+                          % dsm_const.DSM_HOSTNAME)
+
+            """Step 21. Convert to failover"""
+            if cli_mod.convert_to_failover(
+                    primary_server=dsm_const.FAILOVER_HOSTNAME,
+                    failover_server=dsm_const.DSM_HOSTNAME,
+                    primary_admin_name=admin_dict['name'],
+                    primary_admin_pass=dsm_const.DEFAULT_DSM_PASSWORD):
+                RB.print_info(
+                    text="Server[%s] successfully converted to failover." % (
+                        dsm_const.DSM_HOSTNAME))
+            else:
+                RB.print_err(
+                    text="Failed to convert server[%s] to failover\n" % (
+                        dsm_const.DSM_HOSTNAME))
+                sys.exit(1)
+
+            """Step 22. Config replication"""
+            self.ha_page_obj.config_replication_ha(
+                failover=dsm_const.DSM_HOSTNAME)
+            RB.print_info(
+                text="HA config replication for failover entry[%s] is successful\n" % (
+                    dsm_const.DSM_HOSTNAME))
+
+            """Step 23. Check the administrators, domains, keys, policies,
+                hosts, guard points on failover DSMs"""
+            current_count_dict = OrderedDict()
+            current_count_dict['domain_count'] = self.domain_page_obj.total_domain_count(
+            )
+            current_count_dict['admin_count'] = self.admin_page_obj.total_admin_count(
+            )
+            # switch domain
+            self.domain_page_obj.switch_into_a_domain(
+                domain_name=domain_dict['name'])
+            current_count_dict['key_count'] = self.key_page_obj.total_key_count()
+            current_count_dict['host_count'] = self.host_page_obj.total_host_count(
+            )
+            current_count_dict[
+                'policy_count'] = self.policy_page_obj.total_policies_count(
+            )
+            for key in current_count_dict:
+                if current_count_dict[key] != count_dict[key]:
+                    RB.print_err(
+                        text="Security objects count are not same after upgrade.\n")
+                    RB.print_debug(
+                        text="Before upgrade count dict : %s.\n" % count_dict)
+                    RB.print_debug(
+                        text="After upgrade count dict: %s.\n" % count_dict)
+            RB.print_info(
+                text="Security objects count are same after upgrade.\n")
+
+            # """ Step 27. Re-register agents"""
+            # """ Step 28. Add guard points"""
+
+            self.domain_page_obj.exit_from_a_domain()
+            RB.print_info(
+                text="Successfully exited domain[%s].\n" % domain_dict['name'])
+
+            """Step 24. Break HA (cleanup replication)"""
+            self.ha_page_obj.cleanup_replication_ha(
+                failover=dsm_const.DSM_HOSTNAME)
+
+            RB.print_info(
+                text="HA cleanup for failover entry[%s] is successful\n" % (
+                    dsm_const.DSM_HOSTNAME))
+
+            """Step 25. delete HA entry from DSM"""
+            self.ha_page_obj.delete_ha(
+                failover_list=[dsm_const.DSM_HOSTNAME])
+            RB.print_info(
+                text="Failover entry[%s] deleted successfully\n" % (
+                    dsm_const.DSM_HOSTNAME))
+
+            """Step 26.Conver primary server to DSM"""
+            if cli_mod.convert_to_primary(server=dsm_const.DSM_HOSTNAME):
+                RB.print_info(
+                    text="Server[%s] successfully converted to primary server.\n" %
+                    dsm_const.DSM_HOSTNAME)
+            else:
+                RB.print_err(
+                    text="Failed to convert server[%s] to primary\n" %
+                    dsm_const.DSM_HOSTNAME)
+                sys.exit(1)
+
+        except Exception:
+            RB.print_err(text="Backup Restore Failed failed")
+            RB.print_err(text=traceback.format_exc())
+            sys.exit(1)
+
+    def tearDown(self):
+
+        self.driver.quit()
+
+
+if __name__ == "__main__":
+    unittest.main()
Index: UseCases/DSM/TestLink/BackupRestore/testlist
===================================================================
--- UseCases/DSM/TestLink/BackupRestore/testlist	(revision 0)
+++ UseCases/DSM/TestLink/BackupRestore/testlist	(working copy)
@@ -0,0 +1,32 @@
+../../../../../dsm/rest/setup_dsm/create_VA.py --params "BUILD_NUMBER=6.1.0.9203;SINGLE_RUN=1; HOST_IP=10.10.68.141;DSM_SERVER=sys68141.qa.com;HOST=sys68141.qa.com;DSM_USERNAME=admin;BUILD_VERSION=6.1.0"
+
+../../../../../dsm/rest/setup_dsm/setup_cliadmin.py --params "BUILD_NUMBER=6.1.0.9203;SINGLE_RUN=1; HOST_IP=10.10.68.141;DSM_SERVER=sys68141.qa.com;HOST=sys68141.qa.com;DSM_USERNAME=admin;BUILD_VERSION=6.1.0"
+
+../../../../../dsm/rest/setup_dsm/setup_system_admin.py --params "BUILD_NUMBER=6.1.0.9203;SINGLE_RUN=1; HOST_IP=10.10.68.141;DSM_SERVER=sys68141.qa.com;HOST=sys68141.qa.com;DSM_USERNAME=admin;BUILD_VERSION=6.1.0"
+
+../../../../../dsm/rest/setup_dsm/configure_network.py --params "BUILD_NUMBER=6.1.0.9203;SINGLE_RUN=1; HOST_IP=10.10.68.141;DSM_SERVER=sys68141.qa.com;HOST=sys68141.qa.com;DSM_USERNAME=admin;BUILD_VERSION=6.1.0"
+
+../../../../../dsm/rest/setup_dsm/security_genca.py --params "BUILD_NUMBER=6.1.0.9203;SINGLE_RUN=1; HOST_IP=10.10.68.141;DSM_SERVER=sys68141.qa.com;HOST=sys68141.qa.com;DSM_USERNAME=admin;BUILD_VERSION=6.1.0"
+
+../../../../../dsm/rest/setup_dsm/upload_license.py --params "BUILD_NUMBER=6.1.0.9203;SINGLE_RUN=1; HOST_IP=10.10.68.141;DSM_SERVER=sys68141.qa.com;HOST=sys68141.qa.com;DSM_USERNAME=admin;BUILD_VERSION=6.1.0"
+
+../../../../../dsm/rest/setup_dsm/configure_voradmin_domain.py --params "BUILD_NUMBER=6.1.0.9203;SINGLE_RUN=1; HOST_IP=10.10.68.141;DSM_SERVER=sys68141.qa.com;HOST=sys68141.qa.com;DSM_USERNAME=admin;BUILD_VERSION=6.1.0"
+
+
+../../../../../dsm/rest/setup_dsm/create_VA.py --params "BUILD_NUMBER=6.1.0.9203;SINGLE_RUN=1; HOST_IP=10.10.68.142;DSM_SERVER=sys68142.qa.com;HOST=sys68142.qa.com;DSM_USERNAME=admin;BUILD_VERSION=6.1.0"
+
+../../../../../dsm/rest/setup_dsm/setup_cliadmin.py --params "BUILD_NUMBER=6.1.0.9203;SINGLE_RUN=1; HOST_IP=10.10.68.142;DSM_SERVER=sys68142.qa.com;HOST=sys68142.qa.com;DSM_USERNAME=admin;BUILD_VERSION=6.1.0"
+
+../../../../../dsm/rest/setup_dsm/setup_system_admin.py --params "BUILD_NUMBER=6.1.0.9203;SINGLE_RUN=1; HOST_IP=10.10.68.142;DSM_SERVER=sys68142.qa.com;HOST=sys68142.qa.com;DSM_USERNAME=admin;BUILD_VERSION=6.1.0"
+
+../../../../../dsm/rest/setup_dsm/configure_network.py --params "BUILD_NUMBER=6.1.0.9203;SINGLE_RUN=1; HOST_IP=10.10.68.142;DSM_SERVER=sys68142.qa.com;HOST=sys68142.qa.com;DSM_USERNAME=admin;BUILD_VERSION=6.1.0"
+
+../../../../../dsm/rest/setup_dsm/security_genca.py --params "BUILD_NUMBER=6.1.0.9203;SINGLE_RUN=1; HOST_IP=10.10.68.142;DSM_SERVER=sys68142.qa.com;HOST=sys68142.qa.com;DSM_USERNAME=admin;BUILD_VERSION=6.1.0"
+
+../../../../../dsm/rest/setup_dsm/upload_license.py --params "BUILD_NUMBER=6.1.0.9203;SINGLE_RUN=1; HOST_IP=10.10.68.142;DSM_SERVER=sys68142.qa.com;HOST=sys68142.qa.com;DSM_USERNAME=admin;BUILD_VERSION=6.1.0"
+
+../../../../../dsm/rest/setup_dsm/configure_voradmin_domain.py --params "BUILD_NUMBER=6.1.0.9203;SINGLE_RUN=1; HOST_IP=10.10.68.142;DSM_SERVER=sys68142.qa.com;HOST=sys68142.qa.com;DSM_USERNAME=admin;BUILD_VERSION=6.1.0"
+
+
+
+test_BackupRestore.py
Index: UseCases/DSM/TestLink/CBCEncryptionMode/test_GuardpointInHostgroupSupportedAES.py
===================================================================
--- UseCases/DSM/TestLink/CBCEncryptionMode/test_GuardpointInHostgroupSupportedAES.py	(revision 74135)
+++ UseCases/DSM/TestLink/CBCEncryptionMode/test_GuardpointInHostgroupSupportedAES.py	(working copy)
@@ -13,7 +13,8 @@
 
 # Standard python library
 import unittest
-import time, datetime
+import time
+import datetime
 import sys
 import traceback
 from collections import OrderedDict
@@ -45,70 +46,71 @@
 from PageObjectModel.Application.DSM.DSMPages.PoliciesPage import PoliciesPage
 from PageObjectModel.Application.DSM.DSMPages.KeyPage import KeyPage
 
-#Constants
+# Constants
 
-#admin dict
+# admin dict
 admin_dict = {
-    'name':'dsm3039_admin_'+
-        MiscLib.generate_mix_normal_string(length=dsm_const.STRING_LENGTH),
+    'name': 'dsm3039_admin_' +
+    MiscLib.generate_mix_normal_string(length=dsm_const.STRING_LENGTH),
     'password': dsm_const.DEFAULT_INITIAL_PASSWORD,
     'adminType': dsm_const.ALL_ADMIN,
     'description': "dsm3039",
     'readOnly': False
 }
 
-#domain dict
+# domain dict
 domain_dict = {
     "name": "dsm3039_domain_" +
-        MiscLib.generate_mix_normal_string(length=dsm_const.STRING_LENGTH),
+    MiscLib.generate_mix_normal_string(length=dsm_const.STRING_LENGTH),
     "description": "dsm3039"
 }
-#host dict
+# host dict
 host_dict = OrderedDict()
 host_dict["name"] = dsm_const.AGENT_HOSTNAME
 host_dict["desc"] = "dsm3039"
 host_dict["VTE"] = True
 host_dict["enabled"] = True
 
-#host group dict
+# host group dict
 host_group_dict = OrderedDict()
 host_group_dict["name"] = "dsm3039_hostgroup_" +\
-MiscLib.generate_mix_normal_string(length=dsm_const.STRING_LENGTH)
+    MiscLib.generate_mix_normal_string(length=dsm_const.STRING_LENGTH)
 host_group_dict["desc"] = "dsm3039"
 
-#edit hostgroup dict
+# edit hostgroup dict
 edit_hostgroup_dict = OrderedDict()
 edit_hostgroup_dict['name'] = host_group_dict["name"]
 edit_hostgroup_dict['enable_fs_comm'] = True
 
-#expiry date
+# expiry date
 st = datetime.datetime.fromtimestamp(time.time()) +\
-              datetime.timedelta(days=3)
+    datetime.timedelta(days=3)
 expiration_date = st.strftime("%m/%d/%Y")
-#key dict
+# key dict
 key_dict = OrderedDict()
-key_dict['name']= "dsm3039_key_" +\
-        MiscLib.generate_mix_normal_string(length=dsm_const.STRING_LENGTH)
+key_dict['name'] = "dsm3039_key_" +\
+    MiscLib.generate_mix_normal_string(length=dsm_const.STRING_LENGTH)
 key_dict['key_type'] = 'symmetric'
 key_dict['algo'] = 'AES128'
 key_dict['encryp_mode'] = 'CBC-CS1'
 key_dict['expiry_date'] = expiration_date
 key_dict['Key_rotation'] = False
 
-#policy dict
+# policy dict
 policy_dict = OrderedDict()
 policy_dict['name'] = 'policy_dsm3039_' +\
-MiscLib.generate_mix_normal_string(length=dsm_const.STRING_LENGTH)
+    MiscLib.generate_mix_normal_string(length=dsm_const.STRING_LENGTH)
 policy_dict['policy_type'] = 'Standard'
 policy_dict['keyname'] = key_dict['name']
 
-#guard_point_dict
+# guard_point_dict
 guardpoint_hostgroup_dict = OrderedDict()
 guardpoint_hostgroup_dict['name'] = host_group_dict["name"]
 guardpoint_hostgroup_dict['policy'] = policy_dict['name']
 guardpoint_hostgroup_dict['type'] = 'Directory (Auto Guard)'
 guardpoint_hostgroup_dict['path'] = dsm_const.GUARD_PATH
 
+
 class DSM3039(unittest.TestCase):
 
     def __init__(self, testname=None, values=None):
@@ -127,16 +129,17 @@
     def setUp(self):
         """ Step 1. Create domain """
         self.domain_page_obj.create_domain(
-                        domain_dict=domain_dict,
-                        by_method=dsm_const.PREREQ_BY_METHOD)
+            domain_dict=domain_dict,
+            by_method=dsm_const.PREREQ_BY_METHOD)
         """ Step 2. Create admin """
         self.admin_page_obj.create_admin(
-                        admin_dict=admin_dict,
-                        by_method=dsm_const.PREREQ_BY_METHOD)
+            admin_dict=admin_dict,
+            by_method=dsm_const.PREREQ_BY_METHOD)
         """ Step 3. Assign admin to the domain """
-        self.domain_page_obj.assign_an_admin_to_domain(domain_name=domain_dict['name'],
-                                                          admin_name=admin_dict['name'],
-                                                          by_method=dsm_const.PREREQ_BY_METHOD)
+        self.domain_page_obj.assign_an_admin_to_domain(
+            domain_name=domain_dict['name'],
+            admin_name=admin_dict['name'],
+            by_method=dsm_const.PREREQ_BY_METHOD)
 
     def test_guardpoint_in_hostgrp(self):
         """Guard points in a host group is supported with AES-CTS keys
@@ -145,116 +148,127 @@
 
             """ Step 4. Login to dsm. """
             self.login_page_obj.login(user_name=admin_dict['name'],
-                                       password=dsm_const.DEFAULT_INITIAL_PASSWORD,
-                                       validate_login=False,
-                                       print_exception=False)
-            self.domain_page_obj.switch_into_a_domain(domain_name=domain_dict['name'])
+                                      password=dsm_const.DEFAULT_INITIAL_PASSWORD,
+                                      validate_login=False,
+                                      print_exception=False)
+            self.domain_page_obj.switch_into_a_domain(
+                domain_name=domain_dict['name'])
 
             """ Step 5. Add guard points using policies set up with AES-CTS. """
-            #create key
+            # create key
             self.key_page_obj.add_key(key_dict_list=[key_dict],
                                       domain_name=domain_dict['name'])
-            RB.print_info(text="Versioned AES-CTS key[%s] added "\
-                    " successfully.\n" %key_dict['name'])
-            #create policy
+            RB.print_info(text="Versioned AES-CTS key[%s] added "
+                          " successfully.\n" % key_dict['name'])
+            # create policy
             self.policy_page_obj.add_policy(policy_dict=policy_dict)
-            RB.print_info(text="Policy [%s] added successfully.\n" %policy_dict['name'])
+            RB.print_info(
+                text="Policy [%s] added successfully.\n" % policy_dict['name'])
 
             """ Step 6. Create a host group"""
             self.host_page_obj.add_hostgroup(host_group_dict=host_group_dict)
             RB.print_info(text="Host group [%s] added successfully.\n"
-                                            %host_group_dict['name'])
-            #enable FS communication
-            self.host_page_obj.edit_hostgroup_general(edit_hostgroup_dict=edit_hostgroup_dict)
+                          % host_group_dict['name'])
+            # enable FS communication
+            self.host_page_obj.edit_hostgroup_general(
+                edit_hostgroup_dict=edit_hostgroup_dict)
             RB.print_info(text="Host group [%s] edited successfully.\n"
-                                            %edit_hostgroup_dict['name'])
-            #create path on host machine
-            UtilLib.run_cmd_on_remote_host(cmd='mkdir %s'%dsm_const.GUARD_PATH,
-                    server=dsm_const.AGENT_HOSTNAME,
-                    user_name=dsm_const.AGENT_USERNAME,
-                    password=dsm_const.AGENT_PASSWORD)
+                          % edit_hostgroup_dict['name'])
+            # create path on host machine
+            UtilLib.run_cmd(cmd='mkdir %s' % dsm_const.GUARD_PATH,
+                            server=dsm_const.AGENT_HOSTNAME,
+                            user_name=dsm_const.AGENT_USERNAME,
+                            password=dsm_const.AGENT_PASSWORD)
 
-            #add guardpoint to hostgroup
-            self.host_page_obj.add_guardpoint_to_hostgroup(guardpoint_hostgroup_dict=guardpoint_hostgroup_dict)
-            RB.print_info(text="Guardpoint[%s] added to Host group [%s] successful.\n"
-                        %(guardpoint_hostgroup_dict['path'], guardpoint_hostgroup_dict['name']))
+            # add guardpoint to hostgroup
+            self.host_page_obj.add_guardpoint_to_hostgroup(
+                guardpoint_hostgroup_dict=guardpoint_hostgroup_dict)
+            RB.print_info(text="Guardpoint[%s] added to Host group [%s] successful.\n" % (
+                guardpoint_hostgroup_dict['path'], guardpoint_hostgroup_dict['name']))
 
             """ Step 7. Add a capable test host to the host group and verify
             the policy push """
-            #add host on gui
+            # add host on gui
             self.host_page_obj.add_host(host_dict)
             RB.print_info(text="Host [%s] added successfully.\n"
-                                %host_dict['name'])
-            #install and register agent
+                          % host_dict['name'])
+            # install and register agent
             if not agentlib.install_agent(dsm_const.AGENT_HOSTNAME,
                                           dsm_const.AGENT_USERNAME,
                                           dsm_const.AGENT_PASSWORD,
-                                          '6.1.0',#dsm_const.AGENT_BUILD_VERSION,
-                                          '6.1.0.95',#dsm_const.AGENT_BUILD_NUMBER,
+                                          '6.1.0',  # dsm_const.AGENT_BUILD_VERSION,
+                                          '6.1.0.95',  # dsm_const.AGENT_BUILD_NUMBER,
                                           dsm_const.DSM_HOSTNAME,
                                           admin_dict['name'],
                                           dsm_const.DSM_PASSWORD,
                                           domain_dict['name']):
-                RB.print_err(text="Agent installation and registration failed.\n")
+                RB.print_err(
+                    text="Agent installation and registration failed.\n")
                 sys.exit(1)
-            #add host to hostgroup
-            self.host_page_obj.add_host_to_hostgroup(host_group_name=host_group_dict['name'],
-                                    host_list=host_dict['name'])
+            # add host to hostgroup
+            self.host_page_obj.add_host_to_hostgroup(
+                host_group_name=host_group_dict['name'],
+                host_list=host_dict['name'])
             RB.print_info(text="Host[%s] added successfully to hostgroup[%s].\n"
-                                %(host_dict['name'] ,host_group_dict['name']))
+                          % (host_dict['name'], host_group_dict['name']))
 
             """Step 8. Verify the Guard Point is up and runnig at the VTE client and DSM
             Web UI. """
-            self.host_page_obj.check_guardpoint_status(host_name=host_dict['name'],
-                                                    guard_path=guardpoint_hostgroup_dict['path'])
+            self.host_page_obj.check_guardpoint_status(
+                host_name=host_dict['name'],
+                guard_path=guardpoint_hostgroup_dict['path'])
             RB.print_info(text="Guardpoint[%s] is up and running at the VYE host[%s]\n"
-                                %(guardpoint_hostgroup_dict['path'], host_dict['name']))
-            #logout
+                          % (guardpoint_hostgroup_dict['path'], host_dict['name']))
+            # logout
             self.login_page_obj.logout()
 
-        except Exception as exception_obj:
+        except Exception:
             RB.print_err(text=traceback.format_exc())
             sys.exit(1)
 
-
     def tearDown(self):
         """Cleanup
         """
 
         """ Step 9. Delete host."""
         self.host_page_obj.delete_host(host_list=[host_dict['name']],
-                                        domain_name=domain_dict['name'],
-                                        user_name=admin_dict['name'],
-                                        by_method=dsm_const.TEARDOWN_BY_METHOD)
+                                       domain_name=domain_dict['name'],
+                                       user_name=admin_dict['name'],
+                                       by_method=dsm_const.TEARDOWN_BY_METHOD)
         """ Step 10. Delete hostgroup"""
         self.host_page_obj.delete_hostgroup(hostgroup_list=[host_group_dict['name']],
-                                        domain_name=domain_dict['name'],
-                                        user_name=admin_dict['name'],
-                                        by_method=dsm_const.TEARDOWN_BY_METHOD)
+                                            domain_name=domain_dict['name'],
+                                            user_name=admin_dict['name'],
+                                            by_method=dsm_const.TEARDOWN_BY_METHOD)
         """ Step 11. Delete policy."""
         self.policy_page_obj.delete_policy(policy_list=policy_dict['name'],
-                                        by_method=dsm_const.TEARDOWN_BY_METHOD,
-                                        domain_name=domain_dict['name'],
-                                        user_name=admin_dict['name'])
+                                           by_method=dsm_const.TEARDOWN_BY_METHOD,
+                                           domain_name=domain_dict['name'],
+                                           user_name=admin_dict['name'])
         """ Step 12. Delete key."""
         self.key_page_obj.delete_key(key_dict_list=[key_dict],
-                                        by_method=dsm_const.TEARDOWN_BY_METHOD,
-                                        domain_name=domain_dict['name'],
-                                        user_name=admin_dict['name'])
+                                     by_method=dsm_const.TEARDOWN_BY_METHOD,
+                                     domain_name=domain_dict['name'],
+                                     user_name=admin_dict['name'])
 
         """ Step 13. Delete domain."""
         self.domain_page_obj.delete_domain(
-            domain_name=domain_dict['name'], by_method=dsm_const.TEARDOWN_BY_METHOD, print_exception=False)
+            domain_name=domain_dict['name'],
+            by_method=dsm_const.TEARDOWN_BY_METHOD,
+            print_exception=False)
 
         """ Step 14. Delete admin."""
         self.admin_page_obj.delete_admin(
-            admin_name=admin_dict['name'], by_method=dsm_const.TEARDOWN_BY_METHOD, print_exception=False)
-        #remove guard path from host machine
-        UtilLib.run_cmd_on_remote_host(cmd='rm -rf %s'%dsm_const.GUARD_PATH,
-                                        server=dsm_const.AGENT_HOSTNAME,
-                                        user_name=dsm_const.AGENT_USERNAME,
-                                        password=dsm_const.AGENT_PASSWORD)
+            admin_name=admin_dict['name'],
+            by_method=dsm_const.TEARDOWN_BY_METHOD,
+            print_exception=False)
+        # remove guard path from host machine
+        UtilLib.run_cmd(cmd='rm -rf %s' % dsm_const.GUARD_PATH,
+                        server=dsm_const.AGENT_HOSTNAME,
+                        user_name=dsm_const.AGENT_USERNAME,
+                        password=dsm_const.AGENT_PASSWORD)
         self.driver.quit()
 
+
 if __name__ == "__main__":
     unittest.main()
Index: UseCases/DSM/TestLink/Upgrade/test_UpgradeFrom602TolatestDSM.py
===================================================================
--- UseCases/DSM/TestLink/Upgrade/test_UpgradeFrom602TolatestDSM.py	(revision 74135)
+++ UseCases/DSM/TestLink/Upgrade/test_UpgradeFrom602TolatestDSM.py	(working copy)
@@ -20,7 +20,7 @@
 #                                                       #
 #########################################################
 
-#standard python library
+# standard python library
 import unittest
 import sys
 import traceback
@@ -59,63 +59,63 @@
 from PageObjectModel.Application.DSM.DSMPages.KeyPage import KeyPage
 from PageObjectModel.Application.DSM.DSMPages.UpgradePage import UpgradePage
 
-#original dsm constant
+# original dsm constant
 from dsm import constants as const
 
-#Constants
+# Constants
 
-#admin dict
+# admin dict
 admin_dict = {
-    'name':'upgrade_admin_'+
-        MiscLib.generate_mix_normal_string(length=dsm_const.STRING_LENGTH),
+    'name': 'upgrade_admin_' +
+    MiscLib.generate_mix_normal_string(length=dsm_const.STRING_LENGTH),
     'password': dsm_const.DEFAULT_INITIAL_PASSWORD,
     'adminType': dsm_const.ALL_ADMIN,
     'description': "upgradefrom602tolatest",
     'readOnly': False
 }
 
-#domain dict
+# domain dict
 domain_dict = {
     "name": "upgrade_domain_" +
-        MiscLib.generate_mix_normal_string(length=dsm_const.STRING_LENGTH),
+    MiscLib.generate_mix_normal_string(length=dsm_const.STRING_LENGTH),
     "description": "upgradefrom602tolatest"
 }
 
-#host dict
+# host dict
 host_dict = OrderedDict()
 host_dict["name"] = const.AGENT_HOSTNAME
 host_dict["desc"] = "dsm603"
 host_dict["VTE"] = True
 host_dict["enabled"] = True
 
-#server credentials
+# server credentials
 server_dict = {
     'server': WebDriverDict['SELENIUM_SERVER'],
     'user_name': WebDriverDict['SELENIUM_SERVER_USER_NAME'],
     'password':  WebDriverDict['SELENIUM_SERVER_PASSWORD'],
 }
 
-#expiry date
+# expiry date
 st = datetime.datetime.fromtimestamp(time.time()) +\
-              datetime.timedelta(days=3)
+    datetime.timedelta(days=3)
 expiration_date = st.strftime("%m/%d/%Y")
-#key dict
+# key dict
 key_dict = OrderedDict()
-key_dict['name']= "dsm600_key_" +\
-        MiscLib.generate_mix_normal_string(length=dsm_const.STRING_LENGTH)
+key_dict['name'] = "dsm600_key_" +\
+    MiscLib.generate_mix_normal_string(length=dsm_const.STRING_LENGTH)
 key_dict['key_type'] = 'symmetric'
 key_dict['algo'] = 'AES128'
 key_dict['expiry_date'] = expiration_date
 key_dict['Key_rotation'] = False
 
-#policy dict
+# policy dict
 policy_dict = OrderedDict()
 policy_dict['name'] = 'policy_dsm600_' +\
-MiscLib.generate_mix_normal_string(length=dsm_const.STRING_LENGTH)
+    MiscLib.generate_mix_normal_string(length=dsm_const.STRING_LENGTH)
 policy_dict['policy_type'] = 'Standard'
 policy_dict['keyname'] = key_dict['name']
 
-#guard_point_dict
+# guard_point_dict
 guardpoint_dict = OrderedDict()
 guardpoint_dict['host_name'] = host_dict["name"]
 guardpoint_dict['policy'] = policy_dict['name']
@@ -144,7 +144,7 @@
         if dsm_const.PREREQ_BY_METHOD == "gui":
             self.login_page_obj.login()
 
-        """ Step 1. Create VA . """#pending
+        """ Step 1. Create VA . """  # pending
 
         """ Step 2. Create domain . """
         self.domain_page_obj.create_domain(
@@ -158,39 +158,39 @@
 
         """ Step 4. Assign admin to the domain. """
         self.domain_page_obj.assign_an_admin_to_domain(
-                            domain_name=domain_dict['name'],
-                            admin_name=admin_dict['name'],
-                            by_method=dsm_const.PREREQ_BY_METHOD)
+            domain_name=domain_dict['name'],
+            admin_name=admin_dict['name'],
+            by_method=dsm_const.PREREQ_BY_METHOD)
 
         if dsm_const.PREREQ_BY_METHOD == "gui":
             self.login_page_obj.logout()
 
-
     def test_upgrade_from_602_to_latest_dsm(self):
         """Upgrade from 6.0.2 release to latest .
         """
         try:
             """ Step 5. Login to management console."""
             self.login_page_obj.login(user_name=admin_dict['name'],
-                                       password=dsm_const.DEFAULT_INITIAL_PASSWORD,
-                                       validate_login=False,
-                                       print_exception=False)
+                                      password=dsm_const.DEFAULT_INITIAL_PASSWORD,
+                                      validate_login=False,
+                                      print_exception=False)
 
             """ Step 6. Import key-shares and restore configuration from
-                        previous backup""" #Pending
+                        previous backup"""  # Pending
 
             """ Step 7. Add and register hosts.
                         Add guard points
             """
-            self.domain_page_obj.switch_into_a_domain(domain_name=domain_dict['name'])
+            self.domain_page_obj.switch_into_a_domain(
+                domain_name=domain_dict['name'])
 
-            #add host on gui
+            # add host on gui
             self.host_page_obj.add_host(host_dict,
                                         domain_name=domain_dict['name'],
                                         user_name=admin_dict['name'],
                                         install_register_flag=True)
             RB.print_info(text="Host [%s] added successfully.\n"
-                                %host_dict['name'])
+                          % host_dict['name'])
 #            #install and register agent
 #            if not agentlib.install_agent(const.AGENT_HOSTNAME,
 #                                          const.AGENT_USERNAME,
@@ -206,173 +206,203 @@
 #
 #            RB.print_info(text="Agent installation and registration successful.\n")
 
-            #create key
+            # create key
             self.key_page_obj.add_key(key_dict_list=[key_dict],
                                       domain_name=domain_dict['name'])
-            RB.print_info(text="Symmetric key[%s] added "\
-                    " successfully.\n" %key_dict['name'])
+            RB.print_info(text="Symmetric key[%s] added "
+                          " successfully.\n" % key_dict['name'])
 
-            #create policy
+            # create policy
             self.policy_page_obj.add_policy(policy_dict=policy_dict)
-            RB.print_info(text="Policy [%s] added successfully.\n" %policy_dict['name'])
+            RB.print_info(
+                text="Policy [%s] added successfully.\n" % policy_dict['name'])
 
-            #create path on host machine
-            UtilLib.run_cmd_on_remote_host(cmd='mkdir -p %s'%dsm_const.GUARD_PATH,
-                    server=dsm_const.AGENT_HOSTNAME,
-                    user_name=dsm_const.AGENT_USERNAME,
-                    password=dsm_const.AGENT_PASSWORD)
+            # create path on host machine
+            UtilLib.run_cmd(cmd='mkdir -p %s' % dsm_const.GUARD_PATH,
+                            server=dsm_const.AGENT_HOSTNAME,
+                            user_name=dsm_const.AGENT_USERNAME,
+                            password=dsm_const.AGENT_PASSWORD)
             RB.print_info(text="Directory[%s] created successfully on agent[%s].\n"
-                        %(dsm_const.GUARD_PATH, dsm_const.AGENT_HOSTNAME))
+                          % (dsm_const.GUARD_PATH, dsm_const.AGENT_HOSTNAME))
 
-            #add guardpoint to host
-            self.host_page_obj.add_guardpoint_to_host(guardpoint_dict=guardpoint_dict)
+            # add guardpoint to host
+            self.host_page_obj.add_guardpoint_to_host(
+                guardpoint_dict=guardpoint_dict)
             RB.print_info(text="Guardpoint[%s] added to Host [%s] successful.\n"
-                        %(guardpoint_dict['path'], guardpoint_dict['host_name']))
+                          % (guardpoint_dict['path'], guardpoint_dict['host_name']))
 
-            #check guardpoint status
+            # check guardpoint status
             self.host_page_obj.check_guardpoint_status(host_name=host_dict['name'],
-                                                    guard_path=guardpoint_dict['path'])
+                                                       guard_path=guardpoint_dict['path'])
             RB.print_info(text="Guardpoint[%s] is up and running at the VTE host[%s]\n"
-                                %(guardpoint_dict['path'], host_dict['name']))
+                          % (guardpoint_dict['path'], host_dict['name']))
 
             """ Step 8. Setup HA"""
-            #exit from domain
+            # exit from domain
             self.domain_page_obj.exit_from_a_domain()
-            RB.print_info(text="Successfully exited domain[%s].\n" %domain_dict['name'])
+            RB.print_info(
+                text="Successfully exited domain[%s].\n" % domain_dict['name'])
 
-            #add failover entry
+            # add failover entry
             RB.print_info(text="Setup HA in progress...\n")
             self.ha_page_obj.add_ha(failover=const.FAILOVER_HOSTNAME)
-            RB.print_info(text="Failover[%s] entry added successfully\n" %const.FAILOVER_HOSTNAME)
+            RB.print_info(
+                text="Failover[%s] entry added successfully\n" % const.FAILOVER_HOSTNAME)
 
-            #convert to failover
+            # convert to failover
             if cli_mod.convert_to_failover(primary_server=const.DSM_HOSTNAME,
-                                        failover_server=const.FAILOVER_HOSTNAME,
-                                        primary_admin_name=admin_dict['name'],
-                                        primary_admin_pass=dsm_const.DEFAULT_DSM_PASSWORD):
-                RB.print_info(text="Server[%s] successfully converted to failover.\n" %const.FAILOVER_HOSTNAME)
+                                           failover_server=const.FAILOVER_HOSTNAME,
+                                           primary_admin_name=admin_dict['name'],
+                                           primary_admin_pass=dsm_const.DEFAULT_DSM_PASSWORD):
+                RB.print_info(
+                    text="Server[%s] successfully converted to failover.\n" % const.FAILOVER_HOSTNAME)
             else:
-                RB.print_err(text="Failed to convert server[%s] to failover\n" %const.FAILOVER_HOSTNAME)
+                RB.print_err(
+                    text="Failed to convert server[%s] to failover\n" % const.FAILOVER_HOSTNAME)
                 sys.exit(1)
 
-            #config replication
-            self.ha_page_obj.config_replication_ha(failover=const.FAILOVER_HOSTNAME)
-            RB.print_info(text="HA config replication for failover entry[%s] is successful\n" %const.FAILOVER_HOSTNAME)
+            # config replication
+            self.ha_page_obj.config_replication_ha(
+                failover=const.FAILOVER_HOSTNAME)
+            RB.print_info(
+                text="HA config replication for failover entry[%s] is successful\n" % const.FAILOVER_HOSTNAME)
 
-            """ Step 9. Backup configuration""" #pending
+            """ Step 9. Backup configuration"""  # pending
 
             """ Step 10. Break HA (cleanup replication)"""
-            #cleanup replication
-            self.ha_page_obj.cleanup_replication_ha(failover=const.FAILOVER_HOSTNAME)
-            RB.print_info(text="HA cleanup for failover entry[%s] is successful\n" %const.FAILOVER_HOSTNAME)
-            #delete ha
+            # cleanup replication
+            self.ha_page_obj.cleanup_replication_ha(
+                failover=const.FAILOVER_HOSTNAME)
+            RB.print_info(
+                text="HA cleanup for failover entry[%s] is successful\n" % const.FAILOVER_HOSTNAME)
+            # delete ha
             self.ha_page_obj.delete_ha(failover_list=[const.FAILOVER_HOSTNAME])
-            RB.print_info(text="Failover entry[%s] deleted successfully\n" %const.FAILOVER_HOSTNAME)
+            RB.print_info(
+                text="Failover entry[%s] deleted successfully\n" % const.FAILOVER_HOSTNAME)
 
             """ Step 11. Get total count for domains, admins and other security objects."""
             count_dict = OrderedDict()
             count_dict['domain_count'] = self.domain_page_obj.total_domain_count()
             count_dict['admin_count'] = self.admin_page_obj.total_admin_count()
-            #switch domain
-            self.domain_page_obj.switch_into_a_domain(domain_name=domain_dict['name'])
+            # switch domain
+            self.domain_page_obj.switch_into_a_domain(
+                domain_name=domain_dict['name'])
             count_dict['key_count'] = self.key_page_obj.total_key_count()
             count_dict['host_count'] = self.host_page_obj.total_host_count()
             count_dict['policy_count'] = self.policy_page_obj.total_policies_count()
 
             """ Step 12. Upgrade all DSMs"""
-            #exit from domain
+            # exit from domain
             self.domain_page_obj.exit_from_a_domain()
-            RB.print_info(text="Successfully exted domain[%s].\n" %domain_dict['name'])
-            #moun nfs filesystem
+            RB.print_info(
+                text="Successfully exted domain[%s].\n" % domain_dict['name'])
+            # moun nfs filesystem
             if not UtilLib.mount_cmd(mount_src=const.BUILD_SERVER,
-                                            mount_dst=const.BUILD_MOUNT_DIR,
-                                            server_dict=server_dict):
+                                     mount_dst=const.BUILD_MOUNT_DIR,
+                                     server_dict=server_dict):
                 sys.exit(1)
-            #get upgrade file
+            # get upgrade file
             upgrade_file =\
-            dsm_mod.get_dsm_upgrade_file(build_id=const.BUILD_NUMBER,
-                                        build_path_dir=const.BUILD_MOUNT_DIR)
+                dsm_mod.get_dsm_upgrade_file(build_id=const.BUILD_NUMBER,
+                                             build_path_dir=const.BUILD_MOUNT_DIR)
             if not upgrade_file:
                 RB.print_err(text="Failed to get upgrade file.")
                 sys.exit(1)
-            #upgrade primary dsm
+            # upgrade primary dsm
             self.upgrade_page_obj.upgrade_dsm(upgrade_file_path=upgrade_file)
             RB.print_info(text="Primary[%s] DSM upgrade to DSM Version [%s] is complete.\n"
-                            %(const.DSM, const.BUILD_NUMBER))
+                          % (const.DSM, const.BUILD_NUMBER))
 
-            #upgrade failover dsm
+            # upgrade failover dsm
             self.login_page_obj.login(user_name=admin_dict['name'],
-                                       password=dsm_const.DEFAULT_DSM_PASSWORD,
-                                       dsm_url=const.FAILOVER,
-                                       validate_login=False,
-                                       print_exception=False)
+                                      password=dsm_const.DEFAULT_DSM_PASSWORD,
+                                      dsm_url=const.FAILOVER,
+                                      validate_login=False,
+                                      print_exception=False)
             self.upgrade_page_obj.upgrade_dsm(upgrade_file_path=upgrade_file,
-                    dsm_url=const.FAILOVER)
+                                              dsm_url=const.FAILOVER)
             RB.print_info(text="Failover[%s] DSM upgrade to DSM Version [%s] is complete.\n"
-                            %(const.FAILOVER, const.BUILD_NUMBER))
+                          % (const.FAILOVER, const.BUILD_NUMBER))
 
-            #umount nfs build server
+            # umount nfs build server
             if not UtilLib.umount_cmd(umount_dir=const.BUILD_MOUNT_DIR,
-                                server_dict=server_dict):
+                                      server_dict=server_dict):
                 sys.exit(1)
 
             """ Step 13. setup HA After upgrade"""
             RB.print_info(text="Setup HA after upgrade.\n")
             self.login_page_obj.login(user_name=admin_dict['name'],
-                                       password=dsm_const.DEFAULT_DSM_PASSWORD,
-                                       validate_login=False,
-                                       print_exception=False)
-            #add failover entry
+                                      password=dsm_const.DEFAULT_DSM_PASSWORD,
+                                      validate_login=False,
+                                      print_exception=False)
+            # add failover entry
             self.ha_page_obj.add_ha(failover=const.FAILOVER_HOSTNAME)
             RB.print_info(text="Failover[%s] entry added successfully\n"
-                    %const.FAILOVER_HOSTNAME)
+                          % const.FAILOVER_HOSTNAME)
 
-            #convert to failover
+            # convert to failover
             if cli_mod.convert_to_failover(primary_server=const.DSM_HOSTNAME,
-                                        failover_server=const.FAILOVER_HOSTNAME,
-                                        primary_admin_name=admin_dict['name'],
-                                        primary_admin_pass=dsm_const.DEFAULT_DSM_PASSWORD):
-                RB.print_info(text="Server[%s] successfully converted to failover.\n" %const.FAILOVER_HOSTNAME)
+                                           failover_server=const.FAILOVER_HOSTNAME,
+                                           primary_admin_name=admin_dict['name'],
+                                           primary_admin_pass=dsm_const.DEFAULT_DSM_PASSWORD):
+                RB.print_info(
+                    text="Server[%s] successfully converted to failover.\n" % const.FAILOVER_HOSTNAME)
             else:
-                RB.print_err(text="Failed to convert server[%s] to failover\n" %const.FAILOVER_HOSTNAME)
+                RB.print_err(
+                    text="Failed to convert server[%s] to failover\n" % const.FAILOVER_HOSTNAME)
                 sys.exit(1)
 
-            #config replication
-            self.ha_page_obj.config_replication_ha(failover=const.FAILOVER_HOSTNAME)
-            RB.print_info(text="HA config replication for failover entry[%s] is successful\n" %const.FAILOVER_HOSTNAME)
+            # config replication
+            self.ha_page_obj.config_replication_ha(
+                failover=const.FAILOVER_HOSTNAME)
+            RB.print_info(
+                text="HA config replication for failover entry[%s] is successful\n" % const.FAILOVER_HOSTNAME)
 
             """ Step 14. Check the administrators, domains, keys, policies,
                 hosts, guard points on failover DSMs"""
             current_count_dict = OrderedDict()
-            current_count_dict['domain_count'] = self.domain_page_obj.total_domain_count()
-            current_count_dict['admin_count'] = self.admin_page_obj.total_admin_count()
-            #switch domain
-            self.domain_page_obj.switch_into_a_domain(domain_name=domain_dict['name'])
+            current_count_dict['domain_count'] = self.domain_page_obj.total_domain_count(
+            )
+            current_count_dict['admin_count'] = self.admin_page_obj.total_admin_count(
+            )
+            # switch domain
+            self.domain_page_obj.switch_into_a_domain(
+                domain_name=domain_dict['name'])
             current_count_dict['key_count'] = self.key_page_obj.total_key_count()
-            current_count_dict['host_count'] = self.host_page_obj.total_host_count()
-            current_count_dict['policy_count'] = self.policy_page_obj.total_policies_count()
+            current_count_dict['host_count'] = self.host_page_obj.total_host_count(
+            )
+            current_count_dict['policy_count'] = self.policy_page_obj.total_policies_count(
+            )
             for key in current_count_dict:
                 if current_count_dict[key] != count_dict[key]:
-                    RB.print_err(text="Security objects count are not same after upgrade.\n")
-                    RB.print_debug(text="Before upgrade count dict : %s.\n" %count_dict)
-                    RB.print_debug(text="After upgrade count dict: %s.\n" %count_dict)
-            RB.print_info(text="Security objects count are same after upgrade.\n")
+                    RB.print_err(
+                        text="Security objects count are not same after upgrade.\n")
+                    RB.print_debug(
+                        text="Before upgrade count dict : %s.\n" % count_dict)
+                    RB.print_debug(
+                        text="After upgrade count dict: %s.\n" % count_dict)
+            RB.print_info(
+                text="Security objects count are same after upgrade.\n")
 
             """ Step 15. Re-register agents"""
             """ Step 16. Add guard points"""
 
             """ Step 17. Break HA (cleanup replication)"""
-            #exit from domain
+            # exit from domain
             self.domain_page_obj.exit_from_a_domain()
-            RB.print_info(text="Successfully exited domain[%s].\n" %domain_dict['name'])
+            RB.print_info(
+                text="Successfully exited domain[%s].\n" % domain_dict['name'])
 
             RB.print_info(text="Break HA after upgrade.\n")
-            #cleanup replication
-            self.ha_page_obj.cleanup_replication_ha(failover=const.FAILOVER_HOSTNAME)
-            RB.print_info(text="HA cleanup for failover entry[%s] is successful\n" %const.FAILOVER_HOSTNAME)
-            #delete ha
+            # cleanup replication
+            self.ha_page_obj.cleanup_replication_ha(
+                failover=const.FAILOVER_HOSTNAME)
+            RB.print_info(
+                text="HA cleanup for failover entry[%s] is successful\n" % const.FAILOVER_HOSTNAME)
+            # delete ha
             self.ha_page_obj.delete_ha(failover_list=[const.FAILOVER_HOSTNAME])
-            RB.print_info(text="Failover entry[%s] deleted successfully\n" %const.FAILOVER_HOSTNAME)
+            RB.print_info(
+                text="Failover entry[%s] deleted successfully\n" % const.FAILOVER_HOSTNAME)
 
         except Exception as exception_obj:
             RB.print_err(text=traceback.format_exc())
@@ -383,31 +413,32 @@
         """
         """ Step 18. Delete host."""
         self.host_page_obj.delete_host(host_list=[host_dict['name']],
-                                        domain_name=domain_dict['name'],
-                                        user_name=admin_dict['name'],
-                                        by_method=dsm_const.TEARDOWN_BY_METHOD)
+                                       domain_name=domain_dict['name'],
+                                       user_name=admin_dict['name'],
+                                       by_method=dsm_const.TEARDOWN_BY_METHOD)
         """ Step 19. Delete policy."""
         self.policy_page_obj.delete_policy(policy_list=policy_dict['name'],
-                                        by_method=dsm_const.TEARDOWN_BY_METHOD,
-                                        domain_name=domain_dict['name'],
-                                        user_name=admin_dict['name'])
+                                           by_method=dsm_const.TEARDOWN_BY_METHOD,
+                                           domain_name=domain_dict['name'],
+                                           user_name=admin_dict['name'])
         """ Step 20. Delete key."""
         self.key_page_obj.delete_key(key_dict_list=[key_dict],
-                                        by_method=dsm_const.TEARDOWN_BY_METHOD,
-                                        domain_name=domain_dict['name'],
-                                        user_name=admin_dict['name'])
+                                     by_method=dsm_const.TEARDOWN_BY_METHOD,
+                                     domain_name=domain_dict['name'],
+                                     user_name=admin_dict['name'])
 
         """ Step 21. Delete domain."""
         self.domain_page_obj.delete_domain(domain_name=domain_dict['name'],
-                                    by_method=dsm_const.TEARDOWN_BY_METHOD,
-                                    print_exception=False)
+                                           by_method=dsm_const.TEARDOWN_BY_METHOD,
+                                           print_exception=False)
 
         """ Step 22. Delete admin."""
         self.admin_page_obj.delete_admin(admin_name=admin_dict['name'],
-                                    by_method=dsm_const.TEARDOWN_BY_METHOD,
-                                    print_exception=False)
+                                         by_method=dsm_const.TEARDOWN_BY_METHOD,
+                                         print_exception=False)
 
         self.driver.quit()
 
+
 if __name__ == "__main__":
     unittest.main()
