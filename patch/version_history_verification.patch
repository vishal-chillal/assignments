Index: constants.py
===================================================================
--- constants.py	(revision 68717)
+++ constants.py	(working copy)
@@ -1892,6 +1892,11 @@
 d6_1_1_algo = "//a[text() = 'Algorithm']"
 d6_1_1_algo_col_css = "table.dataview>tbody>tr>td:nth-child(6)>span"
 
+d6_1_1_versioned_key = "//th[text() = 'Versioned Key']"
+d6_1_1_versioned_chk_box = "//span[text()='%s']/../../..//input[@type='checkbox' and @disabled]"
+d6_1_1_versioned =  "//th[text() = 'Versioned']"
+d6_1_1_current_version =  "//th[text() = 'Current Version']"
+d6_1_1_key_version_css = "table.dataview>tbody>tr>td:nth-child(5)>span"
 # for finding element by key name, provide key_name also.
 d6_1_1_key_name = "//span[text()='%s']"
 d6_1_1_select_check_box = "//span[text()='%s']/../../..\
@@ -1936,15 +1941,23 @@
 d6_1_1_1_1_key_list = "//form/fieldset/table/tbody/tr[11]/td[2]/span/select"
 d6_1_1_1_1_unique_to_host = "//form/fieldset/table/tbody/tr[12]/td[2]/span/input"
 d6_1_1_1_1_key_refresh_period = "//form/fieldset/table/tbody/tr[13]/td[2]/span/input"
-d6_1_1_1_1_key_version = "//form/fieldset/table/tbody/tr[14]/td[2]/span/span"
-d6_1_1_1_1_key_hash = "//form/fieldset/table/tbody/tr[15]/td[2]/span/span"
-d6_1_1_1_1_auto_key_rotate_chkbox = "//form/fieldset/table/tbody/tr[16]/td[2]/span/input"
+#d6_1_1_1_1_key_version = "//form/fieldset/table/tbody/tr[14]/td[2]/span/span"
+d6_1_1_1_1_key_version = "//label[text()='Key Version']/../..//span/span"
+#d6_1_1_1_1_key_hash = "//form/fieldset/table/tbody/tr[15]/td[2]/span/span"
+d6_1_1_1_1_key_hash = "//label[text()='Key Hash']/../..//span/span"
+d6_1_1_2_1_hash_for_version = "//span[text()='%s']/../../..//span[contains(text(),'****')]"
+d6_1_1_1_1_auto_key_rotate_chkbox = "//label[text()='Automatic Key Rotation']/../..//span/input"
+#d6_1_1_1_1_auto_key_rotate_chkbox = "//form/fieldset/table/tbody/tr[16]/td[2]/span/input"
 d6_1_1_1_1_life_span = "//form/fieldset/table/tbody/tr[16]/td[2]/span/input"
 
+
+
 d6_1_1_1_1_apply = "//form/fieldset/span[19]/div/ul/li[5]/input"
 d6_1_1_1_1_ok = "//form/fieldset/span[19]/div/ul/li[4]/input"
-d6_1_1_1_1_rotate = "//form/fieldset/span[19]/div/ul/li[3]/input"
-d6_1_1_1_1_clone = "//form/fieldset/span[19]/div/ul/li[2]/input"
+#d6_1_1_1_1_rotate = "//form/fieldset/span[19]/div/ul/li[3]/input"
+d6_1_1_1_1_rotate = "//input[@value='Rotate']"
+d6_1_1_1_1_clone = "//input[@value='Clone']"
+#d6_1_1_1_1_clone = "//form/fieldset/span[19]/div/ul/li[2]/input"
 d6_1_1_1_1_cancel = "//form/fieldset/span[19]/div/ul/li[1]/input"
 
 d6_1_1_1_1_alert_close = ".//a[@class='w_close']"
@@ -1967,6 +1980,7 @@
 d6_1_1_2_cancel = "//input[@value='Cancel']"
 d6_1_1_2_expiry_date = "//label[text()='Expiration Date']/../..//input[contains(@name,'date')]"
 
+d6_1_1_2_public_key_upload = "//label[text()='Public Key File']/../..//input[@type='file']"
 d6_1_1_2_resp = "//div[@id='mid-col-2']/div[2]/ul/li/span"
 
 
Index: modules/modules.py
===================================================================
--- modules/modules.py	(revision 68717)
+++ modules/modules.py	(working copy)
@@ -45,10 +45,11 @@
 
     def wait_till_element_available(self, xpath_value="", by_value=By.XPATH, wait_condition = "click", wait_time = 20):
         driver = self.driver
+        time.sleep(3)
         """
         in this function we can give:
         1.xpath/locator by which we can find element
-        2.by_value here we can give By.ID or By.XPATH etc
+        2.by_value here we can give By.ID, By.XPATH, By.LINK_TEXT or By.CSS_SELECTOR etc
         3.wait condition by which we are willing to wait
         4.wait_time is for giving some time to wait for that element.
 
@@ -67,11 +68,15 @@
             element = WebDriverWait(driver, wait_time).until(
                 EC_function_dict[wait_condition]((by_value, xpath_value)))
             return element
-        except TimeoutException:
-            msg = "[INFO] timeout error, element is not clickable." 
+        except TimeoutException as te:
+            msg = "[INFO] timeout error, element %s is not clickable. %s" % (xpath_value, te)
             raise Exception(msg)
             return False
 
+        except Exception as e:
+            print"[ERROR] error occured while waiting for the element.\n%s" % e
+            sys.exit(1)            
+
     def check_popup(self):
         driver = self.driver
         try:
@@ -1577,7 +1582,1775 @@
             self.search_domain_on_gui(domain_name)
             if not self.is_element_present("xpath", c2_1_dom_name % domain_name):
                 print "[INFO] domain not found for deletion."
+                return False
+            driver.find_element_by_xpath(c2_1_single_dom_chkbx % domain_name).click()
+            time.sleep(tout2)
+            driver.find_element_by_xpath(c2_1_del_dom).click()
+            time.sleep(tout2)
+            driver.switch_to_alert().accept()
+            time.sleep(tout2)
+            return True
+        except Exception as e:
+            print "[ERROR] error occoured while deleting domain.\n %s" % e
+            return False
+
+    def delete_global_admin(self, admin=""):
+        try:
+            driver = self.driver
+            driver.find_element_by_xpath(administrator).click()
+            time.sleep(tout2)
+            driver.find_element_by_xpath("//span[contains(text(), '%s')]/../../..//input[@type='checkbox']"%admin).click()
+            driver.find_element_by_xpath(c3_del_dom).click()
+            time.sleep(tout2)
+            alert = driver.switch_to_alert()
+            time.sleep(2)
+            alert.accept()
+            time.sleep(tout2)
+            return True
+        except Exception as msg:
+            print msg
+            return False
+
+    #------------------------- KEYS ----------------------#
+
+    def import_keys(self, export_file_path,  key_list = []):
+        """
+        this function takes
+        1. path of file which is to be import.
+        2. keys_list if any to check of all keys got imported or not.
+        """
+
+        driver = self.driver
+        self.refresh_page()
+        dsm_host = os.environ['HOST']
+        time.sleep(5)
+        self.select_nested_element(d6_keys,
+                    d6_agent_keys,
+                    d6_1_keys,
+                    d6_1_export, 1,
+                    d6_1_export_title)
+
+        driver.find_element_by_xpath(d6_1_3_import).click()
+        e = driver.find_element_by_xpath(d6_1_3_2_tb)
+        print "[INFO] File path for import keys %s" % (export_file_path)
+        try:
+            e.send_keys(export_file_path)
+            time.sleep(5)
+            driver.find_element_by_xpath(d6_1_3_2_ok).click()
+            time.sleep(2)
+            if self.is_element_present("xpath", d6_1_3_feedback_error):
+                print "[FAIL] %s" %(driver.find_element_by_xpath(d6_1_3_feedback_error).text)
+                return False
+            self.refresh_page()
+            driver.find_element_by_xpath(d6_keys).click()
+            time.sleep(1)
+            if key_list != []:
+                r = self.check_import_element(d6_1_1_name_col, d6_1_1_chkbox, key_list)
+                if r != 0:
+                    return False
+            return True
+        except Exception as e:
+            print "[FAIL] failed to import keys"
+            print "[ERROR] %s" % e
+            return False
+
+    def export_keys(self, key_list = []):
+        """
+        this function takes key_list and export path
+        select all keys given in the list and after exporting
+        scp that export file to testmasters /tmp dir.
+        """
+        driver = self.driver
+        exported_keys_file = ''
+        try:
+            dsm_host = os.environ["HOST"]
+            self.ssh_and_clear_reports(val=dsm_host, type=".dat")
+            self.refresh_page()
+            time.sleep(5)
+            self.select_nested_element(
+                d6_keys, d6_agent_keys, d6_1_keys, \
+                d6_1_export, 1, d6_1_export_title)
+            driver.find_element_by_xpath(d6_1_3_export).click()
+
+            for key in key_list:
+                key_name = d6_1_1_select_check_box % key
+                print "[INFO] selecting key : %s" % key_name
+                if not self.is_element_present("xpath", key_name):
+                    print "[FAIL] unable to find key on that page."
+                    return False
+                driver.find_element_by_xpath(key_name).click()
+                time.sleep(tout2)
+            driver.find_element_by_xpath(d6_1_3_2_ok).click()
+            time.sleep(tout2)
+            exported_keys_file = '%s_keys' %dsm_host
+            self.ssh_and_copy_reports(val=exported_keys_file, type=".dat")
+            #get export keys file
+            for file in os.listdir("/tmp"):
+                if file.find(exported_keys_file)!=-1:
+                    exported_keys_file = "/tmp/%s"%file
+                    break
+            print "[INFO] Exported keys file path : [%s]\n" %(exported_keys_file)
+            return exported_keys_file
+
+        except NoSuchElementException, e:
+            print "[FAIL] unable to select given keys."
+            print "[ERROR] %s" % e
+            return False
+
+        except Exception as e:
+            print "[EROOR] Error :: %s"%e
+            return False
+
+    def create_symmetric_agent_key(self, key_name="", cre_date="", exp_date="", algo="", ktype="",
+                                   uniq_host=False, kmethod="", desc="", key_str="", refrsh_period="",
+                                   k_rotation = False, key_vrsn_life_span = "", check_existance = True):
+        if key_name == "":
+            print "Key name cannot be empty"
+            return False
+        else:
+            driver = self.driver
+            self.refresh_page()
+            time.sleep(3)
+        try:
+            driver.find_element_by_xpath(d6_keys).click()
+            time.sleep(1)
+            if check_existance:
+                driver.find_element_by_xpath(d6_1_1_search_tb).clear()
+                driver.find_element_by_xpath(d6_1_1_search_tb).send_keys(key_name)
+                driver.find_element_by_xpath(d6_1_1_go_bt).click()
+                time.sleep(1)
+
+                if self.is_element_present("xpath", d6_1_1_key_name % key_name):
+                    print "[DEBUG] Key %s  Already exist" % key_name
+                    return False
+
+            driver.find_element_by_xpath(d6_1_1_add).click()
+            time.sleep(1)
+
+            driver.find_element_by_xpath(d6_1_1_1_name).clear()
+            driver.find_element_by_xpath(d6_1_1_1_name).send_keys(key_name)
+
+            driver.find_element_by_xpath(d6_1_1_1_desc).clear()
+            driver.find_element_by_xpath(d6_1_1_1_desc).send_keys(desc)
+
+            key_template = driver.find_element_by_xpath(d6_1_1_1_temp_list)
+            Select(key_template).select_by_visible_text("Default_SQL_Symmetric_Key_Template")
+            time.sleep(1)
+            if algo != "":
+                e = driver.find_element_by_xpath(d6_1_1_1_algo_list)
+                Select(e).select_by_visible_text(algo)
+                time.sleep(tout2)
+            if ktype != "":
+                e = driver.find_element_by_xpath(d6_1_1_1_key_list)
+                Select(e).select_by_visible_text(ktype)
+                time.sleep(tout2)
+
+            if uniq_host==True and self.is_element_present("xpath",d6_1_1_1_chkbox):
+                driver.find_element_by_xpath(d6_1_1_1_chkbox).click()
+
+            if kmethod != "":
+                e = driver.find_element_by_xpath(d6_1_1_1_method_list)
+                Select(e).select_by_visible_text(kmethod)
+                time.sleep(tout2)
+
+            if cre_date != "" and self.is_element_present("xpath",d6_1_1_1_creation_date):
+                    driver.find_element_by_xpath(d6_1_1_1_creation_date).send_keys(cre_date)
+
+            if exp_date != "":
+                driver.find_element_by_xpath(d6_1_1_1_expiry_date).clear()
+                driver.find_element_by_xpath(d6_1_1_1_expiry_date).send_keys(exp_date)
+
+            if k_rotation == True and self.is_element_present("xpath",d6_1_1_1_auto_key_rotate_chkbox):
+                driver.find_element_by_xpath(d6_1_1_1_auto_key_rotate_chkbox).click()
+            time.sleep(tout2)
+            if key_vrsn_life_span != "" and self.is_element_present("xpath", d6_1_1_1_life_span):
+                driver.find_element_by_xpath(d6_1_1_1_life_span).send_keys(key_vrsn_life_span)
+
+            driver.find_element_by_xpath(d6_1_1_1_ok).click()
+            time.sleep(tout2)
+            if self.is_element_present("xpath", d6_1_1_1_resp):
+                print "[DEBUG] unable to create key, %s" % driver.find_element_by_xpath(d6_1_1_1_resp).text
+                return False
+            created_key = driver.find_element_by_xpath(d6_1_1_key_name % key_name)
+            if created_key.is_displayed():
+                print "[INFO] Symmetric Key %s is created successfully.\n"%key_name
+                time.sleep(2)
                 return True
+        except Exception as msg:
+            print "Key is not created"
+            print "ERROR : %s"%msg
+            return False
+
+    def create_asymmetric_agent_key(self, key_name="", restricted=False, exp_date="",
+                                    algo="", ktype="", desc="",):
+        if key_name == "":
+            print "Key name cannot be empty"
+            return False
+        else:
+            try:
+                driver = self.driver
+                self.refresh_page()
+                time.sleep(3)
+                driver.find_element_by_xpath(d6_keys).click()
+                time.sleep(1)
+                driver.find_element_by_xpath(d6_1_1_search_tb).clear()
+                driver.find_element_by_xpath(d6_1_1_search_tb).send_keys(key_name)
+                driver.find_element_by_xpath(d6_1_1_go_bt).click()
+                time.sleep(1)
+
+                if self.is_element_present("xpath", d6_1_1_key_name % key_name):
+                    print "[DEBUG] Key %s  Already exist" % key_name
+                    return False
+                driver.find_element_by_xpath(d6_1_1_add).click()
+                time.sleep(1)
+                driver.find_element_by_xpath(d6_1_1_1_asymmetric).click()
+                time.sleep(1)
+                driver.find_element_by_xpath(d6_1_1_2_name).clear()
+                driver.find_element_by_xpath(d6_1_1_2_name).send_keys(key_name)
+                driver.find_element_by_xpath(d6_1_1_2_desc).clear()
+                driver.find_element_by_xpath(d6_1_1_2_desc).send_keys(desc)
+
+                key_template = driver.find_element_by_xpath(d6_1_1_2_temp_list)
+                Select(key_template).select_by_visible_text("Default_SQL_Asymmetric_Key_Template")
+                time.sleep(1)
+                if exp_date != "":
+                    driver.find_element_by_xpath(d6_1_1_2_expiry_date).send_keys(exp_date)
+
+                if algo != "":
+                    e = driver.find_element_by_xpath(d6_1_1_1_algo_list)
+                    Select(e).select_by_visible_text(algo)
+                    time.sleep(tout2)
+
+                if ktype != "":
+                    key_type = driver.find_element_by_xpath(d6_1_1_2_key_list)
+                    Select(key_type).select_by_visible_text(ktype)
+                    time.sleep(1)
+
+                if exp_date != "":
+                    driver.find_element_by_xpath(d6_1_1_1_expiry_date).clear()
+                    driver.find_element_by_xpath(d6_1_1_1_expiry_date).send_keys(exp_date)
+
+                driver.find_element_by_xpath(d6_1_1_1_ok).click()
+                time.sleep(3)
+                if self.is_element_present("xpath", d6_1_1_1_resp):
+                    print "[DEBUG] unable to create key, %s" % driver.find_element_by_xpath(d6_1_1_1_resp).text
+                    return False
+
+                created_key = driver.find_element_by_xpath(d6_1_1_key_name % key_name)
+                if created_key.is_displayed():
+                    print "[INFO] Asymmetric key %s is created successfully.\n"%key_name
+                    return True
+            except Exception as msg:
+                print "Key is not created"
+                print "ERROR : %s"%msg
+                return False
+            
+    def check_popup(self):
+        driver = self.driver
+        try:
+            WebDriverWait(driver, 3).until(EC.alert_is_present(),
+                                            'Timed out waiting for PA creation ' +
+                                            'confirmation popup to appear.')            
+            return True
+        except TimeoutException:
+            return False
+        except Exception as e:
+            print "[ERROR] Error occoured during checking the alert.\n%s" % e
+            sys.exit(1)
+            
+    def find_title(self, xpath, title):
+        """
+        Used to check the title of page while performing smoke testing
+        """
+        driver = self.driver
+        if driver.find_element_by_xpath(xpath).text == title:
+            pass
+            #print "PASSED " + title + " link."
+        else:
+            print "FAILED " + title + " link."
+            return 1
+
+    def try_switch_to_frame(self):
+        """
+        This function will try to switch to frame.
+        """
+        driver = self.driver
+        try:
+            driver.switch_to_frame('content')
+        except:
+            pass
+
+    def refresh_page(self):
+        """
+        This function refreshes the current page and switches to
+        current frame
+        """
+        driver = self.driver
+        time.sleep(tout2)
+        driver.refresh()
+        time.sleep(refresh_tout)
+        try:
+            driver.switch_to_alert().accept()
+        except Exception as msg:
+            ##print msg
+            pass
+        self.try_switch_to_frame()
+
+    def perform_smoke_test(self, menu, submenu, flag, title):
+        """
+        This function will perform the smoke testing on given element
+        """
+
+        driver = self.driver
+        e = driver.find_element_by_xpath(menu)
+        ActionChains(driver).move_to_element(e).perform()
+        time.sleep(tout)
+
+        if flag == 0:
+            driver.find_element_by_xpath(submenu).click()
+            self.find_title(title_xpath, title)
+        time.sleep(tout2)
+
+    def select_element(self, menu, submenu, title):
+        """
+        This function will hover the menu and
+        will select the submenu.
+        """
+
+        driver = self.driver
+        #e = driver.find_element_by_xpath(menu)
+        operation_flag = True
+        operation_count = 0
+        while operation_flag and operation_count<5:
+            try:
+                ActionChains(driver).move_to_element(driver.find_element_by_xpath(menu)).perform()
+                time.sleep(tout)
+                driver.find_element_by_xpath(submenu).click()
+                operation_flag = False
+            except Exception as msg:
+                ##print msg
+                pass
+        operation_count+=1
+        time.sleep(tout)
+        if title != '0':
+            try:
+                self.find_title(title_xpath, title)
+            except:
+                print "Broken link for %s"%title
+                return 0
+
+    def select_nested_element(self, menu, submenu, nested1, nested2, flag, title):
+        """
+        This function will hover the menu and submenu
+        and will select nested menu.
+        """
+
+        driver = self.driver
+        e = driver.find_element_by_xpath(menu)
+        ActionChains(driver).move_to_element(e).perform()
+        time.sleep(tout2)
+        f = driver.find_element_by_xpath(submenu)
+        ActionChains(driver).move_to_element(f).perform()
+        time.sleep(tout2)
+        if flag == 0:
+            driver.find_element_by_xpath(nested1).click()
+        elif flag == 1:
+            g = driver.find_element_by_xpath(nested1)
+            ActionChains(driver).move_to_element(g).perform()
+            time.sleep(tout2)
+            driver.find_element_by_xpath(nested2).click()
+        try:
+            self.find_title(title_xpath, title)
+        except:
+            print "Broken link for %s"%title
+            return 0
+
+    def retrive_total_page_cnt(self):
+        """
+        This function will return the total pages
+        present on that window
+        example:
+        page 1 of 22
+        function will return 22
+        """
+        driver = self.driver
+
+        try:
+            t1 = driver.find_element_by_xpath(c_total_pages).text
+            t2 = t1.split(" ")
+            if t2 != []:
+                page_cnt = int(t2[-1])
+                print "[INFO] total pages = %s" % page_cnt
+                return page_cnt
+
+        except NoSuchElementException as e:
+            print "[ERROR] element not found for retriving total_page_count::\n %s"%e
+        print "[INFO] unable to get total page count."
+        return -1
+
+
+    def retrieve_total(self):
+        """
+        This function will return the total "Total"
+        irrespective of its position
+        """
+
+        driver = self.driver
+        try:
+            t1 = driver.find_element_by_xpath(c_total).text
+            t2 = t1.index(':')
+            t2 = t2 + 1
+            return int(t1[t2:])
+        except:
+            pass
+
+    def delete_element(self, name_col, select_col, key, del_bt, flag=1):
+        """
+        This function will first search the element to delete,
+        if needed will do pagination.
+        Input - name_col select_col(may be checkbox or radio box)
+                key - element to delete.
+        """
+        driver = self.driver
+        prev_cnt = self.retrieve_total()
+        if prev_cnt == 0:
+            print "No element to delete"
+            return 1
+        r = self.search_and_select(name_col, select_col, key, flag)
+        if r == 1:
+            return 1
+
+        driver.find_element_by_xpath(del_bt).click()
+        time.sleep(15)
+        driver.switch_to_alert().accept()
+        time.sleep(15)
+        return 0
+
+    def check_view_cnt(self, menu, flag):
+        """
+        This function will get the selected numbers in the "view" dropdown box
+        as per the settings of System -> General preferences
+        """
+
+        driver = self.driver
+        if flag == 1:
+            driver.find_element_by_xpath(menu).click()
+        return int(Select(driver.find_element_by_xpath(c_view)).\
+                first_selected_option.text)
+
+    def search_and_select(self, name_col, select_col,
+                          key, flag=1, fixed_total_items=0,
+                          opt_col=None, no_divert=False):
+        """
+        This function will search the element and
+        will select appropriate checkbox or radio-box
+        Args:
+             name_col
+             select_col
+             key: text for the item that will be checked
+             flag=1 is search by css, 2 is search by xpath
+             fixed_total_items=1 when the page does not offer //div[@id='totalitems']
+             fixed_total_items=-1 when the second col has extra items
+             that do not have checkbox in the first column
+             opt_col: this field is for additional columns, default is None
+             no_divert: True means keep divert=0, False means do whatever code is doing
+        Returns:
+             0 or 1
+        """
+        driver = self.driver
+        """
+        if flag == 1:
+            col1 = driver.find_elements_by_css_selector(name_col)
+            col2 = driver.find_elements_by_css_selector(select_col)
+        elif flag == 2:
+            col1 = driver.find_elements_by_xpath(name_col)
+            col2 = driver.find_elements_by_xpath(select_col)
+        else:
+            col1 = driver.find_elements_by_xpath(global_name_col)
+            col2 = driver.find_elements_by_xpath(global_select_col)
+        """
+        col3 = None
+        if flag == 1:
+            col1 = driver.find_elements_by_css_selector(name_col)
+            col2 = driver.find_elements_by_css_selector(select_col)
+            if opt_col is not None:
+                col3 = driver.find_elements_by_css_selector(opt_col)
+        elif flag == 2:
+            col1 = driver.find_elements_by_xpath(name_col)
+            col2 = driver.find_elements_by_xpath(select_col)
+            if opt_col is not None:
+                col3 = driver.find_elements_by_xpath(opt_col)
+        else:
+            col1 = driver.find_elements_by_xpath(global_name_col)
+            col2 = driver.find_elements_by_xpath(global_select_col)
+
+        # for example, add admin to domain page, the main admin has no checkbox,
+        # so number for name_col > select_col
+        # In some cases, even when these 2 cols have different size, we keep the
+        # index number for example, log in a voradmin, the voradmin will be the last
+        # item in the list who has no checkbox.
+        divert = 0
+        if len(col1) != len(col2):
+            divert = 1
+        if no_divert:
+            divert = 0
+
+        rflag = 0  # result flag
+        try:
+            prev_cnt = self.retrieve_total()  # real total number of items
+            view = self.check_view_cnt(0, 0)  # max number shows on a page (dropdown choice in view box
+            main_loop = prev_cnt / view
+            main_loop = main_loop + 1
+            t1 = prev_cnt % view
+        except:
+            view = len(col1)
+            t1 = view
+            main_loop = 1
+
+        # when the page has no //div[@id='totalitems'] for the list,
+        # has to give this number in order to loop through all the items
+        #
+        if fixed_total_items > 0:
+            main_loop = fixed_total_items
+
+        found = 0
+        for j in range(main_loop):
+            cnt = view
+            if j+1 == main_loop:
+                cnt = t1
+            for i in range(cnt):
+                time.sleep(tout2)
+                if key == col1[i].text:
+                    rflag = 1
+                    if divert == 1:
+                        i -= 1
+                    col2[i].click()
+                    time.sleep(5)
+                    if col3 is not None:
+                        col3[i].click()
+                    found = 1
+                    break
+            if found == 1:
+                break
+            if j+1 != main_loop:
+                driver.find_elements_by_xpath(next_page_tb)[0].clear()
+                driver.find_elements_by_xpath(next_page_tb)[0].send_keys(j+2)
+                time.sleep(tout2)
+                driver.find_elements_by_xpath(next_page_enter)[0].click()
+                time.sleep(tout2)
+                if flag == 1:
+                    col1 = driver.find_elements_by_css_selector(name_col)
+                    col2 = driver.find_elements_by_css_selector(select_col)
+                elif flag == 2:
+                    col1 = driver.find_elements_by_xpath(name_col)
+                    col2 = driver.find_elements_by_xpath(select_col)
+                else:
+                    col1 = driver.find_elements_by_xpath(global_name_col)
+                    col2 = driver.find_elements_by_xpath(global_select_col)
+            if rflag == 1:
+                break
+
+        if rflag == 0:
+            print "No such " + key
+            return 1
+        return 0
+
+    def check_import_element(self, name_col, select_col, key_list):
+        """
+        This function will search the element and
+        will select appropriate checkbox or radiobox
+        """
+
+        driver = self.driver
+        col1 = driver.find_elements_by_css_selector(name_col)
+        col2 = driver.find_elements_by_css_selector(select_col)
+
+        rflag = 0
+
+        loop_cnt = len(key_list)
+        for j in range(loop_cnt):
+            for i in range(loop_cnt):
+                if key_list[j] == col1[i].text:
+                    rflag = 1
+                    break
+                if i == loop_cnt - 1:
+                    rflag = 2
+                    break
+            if rflag == 1:
+                break
+
+        if rflag == 2:
+            print "Import Failed"
+            return 1
+        return 0
+
+    def db2_ids_agent_log(self, ctrl):
+        """
+        Commmon function to perform db2 and ids agen log
+        operations
+        """
+        driver = self.driver
+        #clicking all check-boxes
+
+        if not driver.find_element_by_xpath(c7_2_2_db_chkbox_1).is_selected():
+            driver.find_element_by_xpath(c7_2_2_db_chkbox_1).click()
+            time.sleep(tout2)
+        if not driver.find_element_by_xpath(c7_2_2_db_chkbox_2).is_selected():
+            driver.find_element_by_xpath(c7_2_2_db_chkbox_2).click()
+            time.sleep(tout2)
+        if not driver.find_element_by_xpath(c7_2_2_db_chkbox_3).is_selected():
+            driver.find_element_by_xpath(c7_2_2_db_chkbox_3).click()
+            time.sleep(tout2)
+        if not driver.find_element_by_xpath(c7_2_2_policy_chkbox_1).\
+                is_selected():
+            driver.find_element_by_xpath(c7_2_2_policy_chkbox_1).click()
+            time.sleep(tout2)
+        if not driver.find_element_by_xpath(c7_2_2_policy_chkbox_2).\
+                is_selected():
+            driver.find_element_by_xpath(c7_2_2_policy_chkbox_2).click()
+            time.sleep(tout2)
+        if not driver.find_element_by_xpath(c7_2_2_policy_chkbox_3).\
+                is_selected():
+            driver.find_element_by_xpath(c7_2_2_policy_chkbox_3).click()
+            time.sleep(tout2)
+        if not driver.find_element_by_xpath(c7_2_2_trans_chkbox_1).\
+                is_selected():
+            driver.find_element_by_xpath(c7_2_2_trans_chkbox_1).click()
+            time.sleep(tout2)
+        if not driver.find_element_by_xpath(c7_2_2_trans_chkbox_2).\
+                is_selected():
+            driver.find_element_by_xpath(c7_2_2_trans_chkbox_2).click()
+            time.sleep(tout2)
+        if not driver.find_element_by_xpath(c7_2_2_trans_chkbox_3).\
+                is_selected():
+            driver.find_element_by_xpath(c7_2_2_trans_chkbox_3).click()
+            time.sleep(tout2)
+
+        if ctrl == 1:
+            if not driver.find_element_by_xpath(c7_2_3_sec_chkbox_1).\
+                    is_selected():
+                driver.find_element_by_xpath(c7_2_3_sec_chkbox_1).click()
+                time.sleep(tout2)
+            if not driver.find_element_by_xpath(c7_2_3_sec_chkbox_2).\
+                    is_selected():
+                driver.find_element_by_xpath(c7_2_3_sec_chkbox_2).click()
+                time.sleep(tout2)
+            if not driver.find_element_by_xpath(c7_2_3_sec_chkbox_3).\
+                    is_selected():
+                driver.find_element_by_xpath(c7_2_3_sec_chkbox_3).click()
+                time.sleep(tout2)
+
+
+        e = driver.find_element_by_xpath(c7_2_2_db_list_1)
+        r = e.text.split('\n')
+
+        flag = 0
+
+        for j in r:
+            e = driver.find_element_by_xpath(c7_2_2_db_list_1)
+            Select(e).select_by_visible_text(j)
+            time.sleep(tout2)
+            e = driver.find_element_by_xpath(c7_2_2_policy_list_1)
+            Select(e).select_by_visible_text(j)
+            time.sleep(tout2)
+            e = driver.find_element_by_xpath(c7_2_2_trans_list_1)
+            Select(e).select_by_visible_text(j)
+            time.sleep(tout2)
+            if ctrl == 1:
+                e = driver.find_element_by_xpath(c7_2_3_sec_list_1)
+                Select(e).select_by_visible_text(j)
+                time.sleep(tout2)
+
+            for k in r:
+                e = driver.find_element_by_xpath(c7_2_2_file_level)
+                Select(e).select_by_visible_text(k)
+                time.sleep(tout2)
+                e = driver.find_element_by_xpath(c7_2_2_syslog_level)
+                Select(e).select_by_visible_text(k)
+                time.sleep(tout2)
+                e = driver.find_element_by_xpath(c7_2_2_server_level)
+                Select(e).select_by_visible_text(k)
+                time.sleep(tout2)
+
+                slevel = log_level_value[k]
+                mlevel = log_level_value[j]
+
+                if slevel <= mlevel:
+                    e = driver.find_elements_by_css_selector\
+                            (c7_2_2_file_level_val)
+                    for l in e:
+                        if l.text != j:
+                            print "FAILED level ",j
+                            flag = 1
+                    if flag == 1:
+                        break
+                    e = driver.find_elements_by_css_selector\
+                            (c7_2_2_syslog_level_val)
+                    for l in e:
+                        if l.text != j:
+                            print "FAILED level ",j
+                            flag = 1
+                    if flag == 1:
+                        break
+                    e = driver.find_elements_by_css_selector\
+                            (c7_2_2_server_level_val)
+                    for l in e:
+                        if l.text != j:
+                            print "FAILED level ",j
+                            flag = 1
+                    if flag == 1:
+                        break
+                else:
+                    e = driver.find_elements_by_css_selector\
+                            (c7_2_2_file_level_val)
+                    for l in e:
+                        if l.text != k:
+                            print "FAILED level ",j
+                            flag = 1
+                    if flag == 1:
+                        break
+                    e = driver.find_elements_by_css_selector\
+                            (c7_2_2_syslog_level_val)
+                    for l in e:
+                        if l.text != k:
+                            print "FAILED level ",j
+                            flag = 1
+                    if flag == 1:
+                        break
+                    e = driver.find_elements_by_css_selector\
+                            (c7_2_2_server_level_val)
+                    for l in e:
+                        if l.text != k:
+                            print "FAILED level ",j
+                            flag = 1
+                    if flag == 1:
+                        break
+            if flag == 1:
+                flag = 0
+                continue
+
+    def ssh_and_copy_reports(self, val, type, os_type="linux",
+                             server = os.environ['SERVER'],
+                             user_name = os.environ['SERVER_USER_NAME'],
+                             password = os.environ['SERVER_PASS']):
+        """
+        This function will ssh to the selenium server
+        and copies the reports to testmaster's /tmp dir
+        """
+        SCP_CMD = 'scp '
+        SERVER = server
+        USER_NAME = user_name
+        RESP1 = "The authenticity.*"
+        RESP2 = USER_NAME
+        RESP3 = "ssh.*"
+        DENIED = "Permission denied.*"
+        MAX_TIME = 100
+        PASSWORD = password
+        print "SERVER_USER_NAME=%s"%USER_NAME
+        print "SERVER_PASSWORD=%s"%PASSWORD
+        if USER_NAME == "Administrator":
+            os_type="windows"
+        if os_type == "windows":
+            SRC_DIR = ":/cygdrive/c/Users/%s/Downloads/"%USER_NAME
+        else:
+            SRC_DIR = ":~/Downloads/"
+        DEST_DIR = " /tmp/"
+        RM_CMD = "rm -rf /tmp/"
+
+        os.system(RM_CMD + val + "*" + type)
+        time.sleep(3)
+
+        cmd = SCP_CMD + USER_NAME + "@" + SERVER + SRC_DIR + "*" + val + "*" + type + DEST_DIR
+
+        i = 0
+        while True:
+            print "[DEBUG] cmd> ", cmd
+            child = pexpect.spawn(cmd)
+            child.logfile = sys.stdout
+            index = child.expect([RESP1, USER_NAME, RESP3])
+            #index = 0 if ssh connection is first time.
+            #index = 1 if ssh connection is already exist.
+            print "**Index ", index
+            if index == 0:
+                child.sendline('yes')
+                child.expect(USER_NAME + "@" + SERVER + ".*", timeout=MAX_TIME)
+                child.sendline(PASSWORD)
+                child.expect(val + ".*", timeout=MAX_TIME)
+                print child.after
+                print child.before
+            elif index == 1:
+                child.sendline(PASSWORD)
+                time.sleep(2)
+                # Output String gets truncated, so search string should be
+                # short
+                print "VAL IN COPY = %s"%val
+                if val == "Administrators":
+                    print "A"
+                    val = "Admin"
+                if val.find("backup")>=0:
+                    print "B"
+                    child.expect("backup", timeout=MAX_TIME)
+                else:
+                    print "C"
+                    child.expect([val, 'Vormetric', 'root', '$'], timeout=MAX_TIME)
+                time.sleep(2)
+            elif index == 3:
+                print "ssh: connect to " + SERVER + " port 22: Connection refused"
+                sys.exit(1)
+            files=os.listdir('/tmp')
+            print "FILES START ########"
+            print files
+            print "FILES END ##########"
+            found = 0
+            for f in files:
+                if val in f:
+                    print "FOUND VAL=%s in F = %s"%(val, f)
+                    found = 1
+                    break
+            if found == 1:
+                break
+            time.sleep(60)
+            i = i + 1
+            if i >= 5:
+                print "[WARNING] File not found. [%s, %s]" % (val, type)
+                break
+        child.close()
+
+    def ssh_and_clear_reports(self, val, type, os_type = "linux",
+                              server = os.environ['SERVER'],
+                              user_name = os.environ['SERVER_USER_NAME'],
+                              password = os.environ['SERVER_PASS']):
+        """
+        This function will ssh to the selenium server
+        and copies the reports to testmaster's /tmp dir
+        """
+        SSH_CMD = 'ssh '
+        SERVER = server
+        USER_NAME = user_name
+        RESP1 = "The authenticity.*"
+        RESP2 = ".*"
+        RESP3 = "ssh.*"
+        DENIED = "Permission denied.*"
+        MAX_TIME = 100
+        PASSWORD = password
+        print "SERVER = %s"%SERVER
+        print "USERNAME = %s"%USER_NAME
+        print "PASSWORD = %s"%PASSWORD
+        if USER_NAME == "Administrator":
+            os_type = "windows"
+        if os_type == "windows":
+            LS_DOWN = "ls /cygdrive/c/Users/%s/Downloads/"%USER_NAME
+            RM_DOWN = 'rm -f /cygdrive/c/Users/%s/Downloads/'%USER_NAME
+        else:
+            LS_DOWN = 'ls ~/Downloads/'
+            RM_DOWN = 'rm -f ~/Downloads/'
+
+        child = pexpect.spawn(SSH_CMD + USER_NAME + "@" + SERVER)
+        index = child.expect([RESP1, USER_NAME, RESP3])
+        #index = 0 if ssh connection is first time.
+        #index = 1 if ssh connection is already exist.
+        if index == 0:
+            child.sendline('yes')
+            child.expect(USER_NAME + "@" + SERVER + ".*", timeout=MAX_TIME)
+            child.sendline(PASSWORD)
+            child.expect(USER_NAME + ".*", timeout=MAX_TIME)
+        elif index == 1:
+            child.sendline(PASSWORD)
+            child.expect(USER_NAME + ".*", timeout=MAX_TIME)
+        elif index == 3:
+            print "ssh: connect to " + SERVER + " port 22: Connection refused"
+            sys.exit(1)
+
+        child.sendline(LS_DOWN + val + "*" + type)
+        child.expect(USER_NAME, timeout=MAX_TIME)
+        #print child.before
+        #print child.after
+        child.sendline(RM_DOWN + val + "*" + type)
+        time.sleep(2)
+        child.expect('rm')
+        child.close()
+
+    def reports_menu_parser(self, val, type, info):
+        """
+        This function takes the report file.
+        Parses it. And check against gui report values.
+        """
+
+        driver = self.driver
+        if os.environ['BROWSER'] == 'chrome':
+            os.system('rm -rf /tmp/*')
+            time.sleep(2)
+            self.ssh_and_clear_reports(val, type)
+            driver.find_element_by_xpath(c5_download).click()
+            time.sleep(2)
+            self.ssh_and_copy_reports(val, type)
+
+            files = os.listdir('/tmp')
+            print "FILES = %s\n"%files
+            temp_files = os.listdir('/tmp/')
+            print "TEMP_FIELS = %s\n"%temp_files
+            file_name = ''
+
+            for i in files:
+                if val in i:
+                    file_name = i
+                    break
+
+            print "FILENAME = %s\n"%file_name
+            fp = open('/tmp/' + file_name)
+
+            keys = info.keys()
+            vals = info.values()
+
+            flag = 0
+            flag1 = 0
+            for i in range(len(keys)):
+                flag = 0
+                flag1 = 0
+                for line in fp:
+                    flag1 = 1
+                    s1 = re.search(keys[i], line)
+                    if s1:
+                        s1 = re.search(str(vals[i]), line)
+                        flag = 1
+                        break
+                if flag == 0 and flag1 == 1:
+                    flag = 2
+                    break
+            if flag == 2:
+                print val + " Report failed to download"
+            else:
+                print val + " Report passed to download"
+
+    def return_report_input(self, name_col, sel_col):
+        """
+        This function returns the dictionary containing values and keys to
+        check against Reports menu.
+        """
+        driver = self.driver
+        info = dict ()
+        col1 = driver.find_elements_by_css_selector(name_col)
+        col2 = driver.find_elements_by_css_selector(sel_col)
+
+        for i in range(len(col1)):
+            info[col1[i].text] = col2[i].text
+        return info
+
+    def check_gui_report(self, name_col, type_col, info, val):
+        """
+        This function will take i/p dictionary and will check
+        gui reports column values.
+        """
+        driver = self.driver
+        time.sleep(10)
+        col1 = driver.find_elements_by_css_selector(name_col)
+        col2 = driver.find_elements_by_css_selector(type_col)
+
+        infos = info.keys()
+        types = info.values()
+
+        fail = 0
+        for i in range(len(col1)):
+            if infos[i] == col1[i].text or types[i] == col2[i].text:
+                pass
+            else:
+                fail = 1
+
+        if fail == 1:
+            print "Fail Gui " + val + " reports"
+            sys.exit()
+        else:
+            print "Passed Gui " + val +" reports "
+
+    def check_gui_report1(self, name_col, type_col, info, val):
+        """
+        This function will take i/p dictionary and will check
+        gui reports column values. Used for Executive summary report
+        """
+        driver = self.driver
+        col1 = driver.find_elements_by_css_selector(name_col)
+        col2 = driver.find_elements_by_css_selector(type_col)
+
+        infos = info.keys()
+        types = info.values()
+
+        fail = 0
+        for i in range(len(col1)):
+            for j in range(len(infos)):
+                if infos[j] == col1[i].text:
+                    if str(info[col1[i].text]) == col2[i].text:
+                        found = 1
+                        break
+
+        if fail == 1:
+            print "Fail Gui " + val + " reports"
+            sys.exit()
+        else:
+            print "Passed Gui " + val +" reports "
+
+    def select_resource(self, val, flag):
+        """
+        Select time under "Security Selection Rules"
+        ==> flag : is used to check exclude option
+        """
+
+        driver = self.driver
+
+        vals = []
+        if ',' in val:
+            vals = val.split(',')
+        else:
+            vals.append(val)
+
+        for e in vals:
+            driver.find_element_by_xpath(d9_1_1_add_security_bt).click()
+            time.sleep(tout2)
+            if flag != 0:
+                driver.find_element_by_xpath(d9_1_1_1_allow_browsing).click()
+                time.sleep(tout2)
+                driver.find_element_by_xpath(d9_1_1_1_resource_exclude).click()
+                time.sleep(tout2)
+            driver.find_element_by_xpath(d9_1_1_1_resource_select).click()
+            time.sleep(tout2)
+            ret = self.search_and_select(d9_1_1_1_entity_name_col, \
+                    d9_1_1_1_entity_chkbox_col, e, flag=1)
+            if ret != 0:
+                print "\n Failed to select '%s' Resource set" %e
+                driver.find_element_by_xpath(d9_1_1_1_cancel_bt).click()
+                return 1
+            time.sleep(tout2)
+            driver.find_element_by_xpath(d9_1_1_1_select_entity_bt).click()
+            #  select action ##
+            self.select_action("all_ops", 1)
+            #  select effect ##
+            time.sleep(tout2)
+            self.select_effect(3)
+            driver.find_element_by_xpath(d9_1_1_1_ok_bt).click()
+            time.sleep(tout2)
+            if flag != 0:
+                cols = driver.find_elements_by_css_selector(d9_1_1_1_browsing_col)
+                vlen = len(cols)
+                if cols[vlen-1].text == "No":
+                    print "PASSED : Disabled Allow Browsing options for Resource set"
+                else:
+                    print "FAILED : Disabled Allow Browsing options for Resource set"
+
+    def select_effect(self, val):
+        """
+        Select effect under "Security Selection Rules"
+
+        val = 3 : Permit, Apply key, Audit
+        val = 2 : Audit, Deny
+        """
+
+        driver = self.driver
+
+        driver.find_element_by_xpath(d9_1_1_1_effect_select).click()
+        time.sleep(tout2)
+        if val == 3:
+            ret = self.search_and_select(d9_1_1_1_effect_name_list, \
+                d9_1_1_1_effect_chkbox, "Permit")
+            ret = self.search_and_select(d9_1_1_1_effect_name_list, \
+                d9_1_1_1_effect_chkbox, "Apply Key")
+            ret = self.search_and_select(d9_1_1_1_effect_name_list, \
+                d9_1_1_1_effect_chkbox, "Audit")
+        if val == 2:
+            ret = self.search_and_select(d9_1_1_1_effect_name_list, \
+                d9_1_1_1_effect_chkbox, "Audit")
+            ret = self.search_and_select(d9_1_1_1_effect_name_list, \
+                d9_1_1_1_effect_chkbox, "Deny")
+        time.sleep(tout2)
+        driver.find_element_by_xpath(d9_1_1_1_select_effect_bt).click()
+        driver.find_element_by_xpath(d9_1_1_1_ok_bt).click()
+        time.sleep(tout2)
+
+    def select_action(self, val, flag):
+        """
+        Select action under "Security Selection Rules"
+        """
+
+        driver = self.driver
+
+        driver.find_element_by_xpath(d9_1_1_1_action_select).click()
+        time.sleep(tout2)
+        ret = self.search_and_select(d9_1_1_1_action_name_list, \
+                d9_1_1_1_action_chkbox, val, flag=1)
+        if ret != 0:
+            print "\n Failed to select '%s' Action" %val
+            return 1
+        time.sleep(tout2)
+        driver.find_element_by_xpath(d9_1_1_1_select_action_bt).click()
+        time.sleep(tout2)
+        if flag == 0:
+            self.select_effect(3)
+            time.sleep(tout2)
+
+    def select_key(self, val, resource = "", flag = 0):
+        """
+        Select key in "Key Selection Rules"
+        ==> resource - if given, select resource in key selection rule
+        ==> flag - if set, select resource
+        """
+
+        driver = self.driver
+
+        driver.find_element_by_xpath(d9_1_1_add_key_bt).click()
+        time.sleep(tout2)
+        if flag == 1:
+            driver.find_element_by_xpath(d9_1_1_2_resouce_select).click()
+            time.sleep(tout2)
+            ret = self.search_and_select(d9_1_1_1_entity_name_col, \
+                    d9_1_1_1_entity_chkbox_col, resource,flag=1)
+            if ret != 0:
+                print "\n Failed to select '%s' Resource set"%resource
+                return 1
+            time.sleep(tout2)
+            driver.find_element_by_xpath(d9_1_1_1_select_entity_bt).click()
+
+        driver.find_element_by_xpath(d9_1_1_2_key_select).click()
+        time.sleep(tout2)
+        driver.find_element_by_xpath(d9_1_1_2_key_search_tb).clear()
+        driver.find_element_by_xpath(d9_1_1_2_key_search_tb).send_keys(val)
+        time.sleep(tout2)
+        driver.find_element_by_xpath(d9_1_1_2_key_go_bt).click()
+        time.sleep(tout2)
+        ret = self.search_and_select(d9_1_1_2_key_name_col, \
+               d9_1_1_2_key_chkbox_col, val, flag=1)
+        if ret != 0:
+            print "\n Failed to select Key %s in Key Selection Rule" %val
+            return 1
+        time.sleep(tout2)
+        driver.find_element_by_xpath(d9_1_1_2_select_key_bt).click()
+        time.sleep(tout2)
+        driver.find_element_by_xpath(d9_1_1_2_ok_bt).click()
+
+    def select_user(self, val):
+        """
+        Select time under "Security Selection Rules"
+        """
+
+        driver = self.driver
+
+        vals = []
+        if val == "ALL":
+            vals = actions.keys()
+        elif ',' in val:
+            vals = val.split(',')
+        else:
+            vals.append(val)
+        for e in vals:
+            driver.find_element_by_xpath(d9_1_1_add_security_bt).click()
+            time.sleep(tout2)
+            self.select_action("all_ops", 1)
+            time.sleep(tout2)
+            driver.find_element_by_xpath(d9_1_1_1_user_select).click()
+            time.sleep(tout2)
+            ret = self.search_and_select(d9_1_1_1_entity_name_col, \
+                    d9_1_1_1_entity_chkbox_col, e)
+            if ret != 0:
+                print "\n Failed to select '%s' Resource set" %e
+                return 1
+            time.sleep(tout2)
+            driver.find_element_by_xpath(d9_1_1_1_select_entity_bt).click()
+            time.sleep(tout2)
+            #  select effect ##
+            self.select_effect(3)
+            time.sleep(tout2)
+            driver.find_element_by_xpath(d9_1_1_1_ok_bt).click()
+            time.sleep(tout2)
+
+    def select_time(self, val):
+        """
+        Select time under "Security Selection Rules"
+        """
+
+        driver = self.driver
+
+        driver.find_element_by_xpath(d9_1_1_add_security_bt).click()
+        time.sleep(tout2)
+
+        driver.find_element_by_xpath(d9_1_1_1_when_select).click()
+        time.sleep(tout2)
+        ret = self.search_and_select(d9_1_1_1_entity_name_col, \
+                d9_1_1_1_entity_chkbox_col, val)
+        if ret != 0:
+            print "\n Failed to select '%s' Time set" %val
+            return 1
+        time.sleep(tout2)
+        driver.find_element_by_xpath(d9_1_1_1_select_entity_bt).click()
+        time.sleep(tout2)
+
+        #  select action ##
+        self.select_action("all_ops", 1)
+        time.sleep(tout2)
+
+        #  select effect ##
+        self.select_effect(3)
+        time.sleep(tout2)
+
+        driver.find_element_by_xpath(d9_1_1_1_ok_bt).click()
+        time.sleep(tout2)
+
+    def select_dataxform_key(self, val):
+        """
+        Select key in "Dataxform Selection Rules"
+        """
+
+        driver = self.driver
+
+        driver.find_element_by_xpath(d9_1_1_add_dataxform_bt).click()
+        time.sleep(tout2)
+        driver.find_element_by_xpath(d9_1_1_2_key_select).click()
+        time.sleep(tout2)
+        driver.find_element_by_xpath(d9_1_1_2_key_search_tb).clear()
+        driver.find_element_by_xpath(d9_1_1_2_key_search_tb).send_keys(val)
+        time.sleep(tout2)
+        driver.find_element_by_xpath(d9_1_1_2_key_go_bt).click()
+        time.sleep(tout2)
+        ret = self.search_and_select(d9_1_1_2_key_name_col, \
+               d9_1_1_2_key_chkbox_col, val)
+        if ret != 0:
+            print "\n Failed to select Key %s in Key Selection Rule" %val
+            return 1
+        time.sleep(tout2)
+        driver.find_element_by_xpath(d9_1_1_2_select_key_bt).click()
+        time.sleep(tout2)
+        driver.find_element_by_xpath(d9_1_1_2_ok_bt).click()
+
+    def process_selection(self, val):
+        """
+        """
+
+        driver = self.driver
+        driver.find_element_by_xpath(d9_1_1_1_process_select).click()
+        time.sleep(tout2)
+        ret = self.search_and_select(d9_1_1_1_entity_name_col, \
+                d9_1_1_1_entity_chkbox_col, val)
+        if ret != 0:
+            print "\n Failed to select '%s' Process" %val
+            return 1
+        time.sleep(tout2)
+        driver.find_element_by_xpath(d9_1_1_1_select_entity_bt).click()
+        time.sleep(tout2)
+        #  select action ##
+        self.select_action("all_ops", 1)
+        time.sleep(tout2)
+        #  select effect ##
+        self.select_effect(3)
+        time.sleep(tout2)
+
+    def select_process(self, val, flag):
+        """
+        Select process under "Security Selection Rules"
+        ==> flag : is used to check exclude option
+        """
+
+        driver = self.driver
+
+        if val == "ALL":
+            for entry in pnames:
+                driver.find_element_by_xpath(d9_1_1_add_security_bt).click()
+                time.sleep(tout2)
+                if flag != 0:
+                    driver.find_element_by_xpath(d9_1_1_1_allow_browsing).click()
+                    time.sleep(tout2)
+                    driver.find_element_by_xpath(d9_1_1_1_process_select).click()
+                    time.sleep(tout2)
+                self.process_selection(entry);
+                time.sleep(tout2)
+                driver.find_element_by_xpath(d9_1_1_1_ok_bt).click()
+                time.sleep(tout2)
+        else:
+            plist = []
+            if ',' in val:
+                plist = val.split(',')
+            else:
+                plist.append(val)
+            for entry in plist:
+                driver.find_element_by_xpath(d9_1_1_add_security_bt).click()
+                time.sleep(tout2)
+                if flag != 0:
+                    driver.find_element_by_xpath(d9_1_1_1_process_select).click()
+                    time.sleep(tout2)
+                self.process_selection(entry)
+                time.sleep(tout2)
+                driver.find_element_by_xpath(d9_1_1_1_ok_bt).click()
+                time.sleep(tout2)
+                if flag != 0:
+                    cols = driver.find_elements_by_css_selector(d9_1_1_1_browsing_col)
+                    vlen = len(cols)
+                    if cols[vlen-1].text == "No":
+                        print "PASSED : Disabled Allow Browsing Exclude for User set"
+                    else:
+                        print "FAILED : Disabled Allow Browsing options for User set"
+
+    def select_policy(self, name):
+
+        driver = self.driver
+
+        driver.find_element_by_xpath(d9_1_name_tb).clear()
+        driver.find_element_by_xpath(d9_1_name_tb).send_keys(name)
+        time.sleep(tout2)
+        driver.find_element_by_xpath(d9_1_go_bt).click()
+        time.sleep(tout2)
+        ret = self.search_and_select(d9_1_1_name_col, \
+               d9_1_1_chkbox_col, name)
+        if ret != 0:
+            print "\nFailed to select Policy %s" %name
+        time.sleep(tout2)
+
+        policy_list = driver.find_elements_by_css_selector(d9_1_1_name_col)
+        for i in range(len(policy_list)):
+            if policy_list[i].text == name:
+                policy_list[i].click()
+                break
+
+    def add_process(self, val1, val2):
+        """
+        """
+        driver = self.driver
+
+        time.sleep(tout2)
+        driver.find_element_by_xpath(d9_1_4_1_add_bt).click()
+        time.sleep(tout2)
+        #driver.find_element_by_xpath(d9_1_4_1_1_dir_tb).clear()
+        driver.find_element_by_xpath(d9_1_4_1_1_dir_tb).send_keys(val1)
+        time.sleep(tout2)
+        #driver.find_element_by_xpath(d9_1_4_1_1_file_tb).clear()
+        driver.find_element_by_xpath(d9_1_4_1_1_file_tb).send_keys\
+            (val2.split('_')[1])
+        time.sleep(tout2)
+        driver.find_element_by_xpath(d9_1_4_1_1_ok_bt).click()
+        time.sleep(tout2)
+
+    def add_gp(self, Host, gp, policy, secure_start = False):
+        """
+        """
+
+        driver = self.driver
+        #  Now, add a guard point with this policy
+        #  and check first rule is getting evaluated or not
+        driver.find_element_by_xpath(d4_main_hosts).click()
+        driver.find_element_by_xpath(d4_1_search_tb).clear()
+        driver.find_element_by_xpath(d4_1_search_tb).send_keys(Host)
+        driver.find_element_by_xpath(d4_1_go_bt).click()
+
+        #  search enter host name in Host Name coloumn
+
+        time.sleep(tout2)
+        ele = driver.find_element_by_css_selector(d4_3_1_host_col)
+        if ele.text == Host:
+            time.sleep(tout2)
+            ele.click()
+
+            #  after click on searched host, click on GuardFS and Guard btn
+            driver.find_element_by_xpath(d4_3_guard_fs).click()
+            time.sleep(5)
+            driver.find_element_by_xpath(d4_3_1_guard).click()
+            time.sleep(tout2)
+
+            #  enter policy, guard type, path and click ok btn
+            Select(driver.find_element_by_xpath(d4_3_1_guardfs_policy)).\
+                select_by_visible_text(policy)
+            driver.find_element_by_xpath(d4_3_1_guardfs_path).clear()
+            driver.find_element_by_xpath(d4_3_1_guardfs_path).send_keys(gp)
+            time.sleep(tout2)
+            if secure_start:
+                if not driver.find_element_by_xpath(d4_3_1_guardfs_secure_start).is_selected():
+                    driver.find_element_by_xpath(d4_3_1_guardfs_secure_start).click()
+            driver.find_element_by_xpath(d4_3_1_guardfs_ok_btn).click()
+
+            def check_status():
+
+                # click on refresh btn
+                time.sleep(25)
+                driver.find_element_by_xpath(d4_3_1_refresh).click()
+                time.sleep(2)
+
+                #  after refresh, check gp column and click on status
+
+                ele = driver.find_elements_by_css_selector(d4_3_1_prot_path)
+                sts = driver.find_elements_by_css_selector(d4_3_1_status_col)
+                status = ''
+
+                if not ele:
+                    print 'Failure in adding guard point, guard path not found. '
+                    sys.exit()
+                if ele:
+                    try:
+                        ind = [ele.index(itm) for itm in ele if itm.text == gp][0]
+                    except Exception as msg:
+                        ##print msg
+                        pass
+                    try:
+                        match = [item for item in ele if item.text == gp]
+                    except Exception as msg:
+                        match = ""
+                        ##print msg
+                    if not len(match):
+                        print 'Failure in adding guard point, wrong guard path found.'
+                        sys.exit()
+                    stat = sts[ind]
+                    stat.click()
+                    time.sleep(15)
+
+                    try:
+                        status = driver.find_element_by_xpath(d4_3_1_status_guarded).text
+                    except Exception as msg:
+                        print "[ERROR] error in checking guard status of gp \n%s"%msg
+                        pass
+
+                    print "Status :", status
+                    if not status in ('Guarded', 'guarded'):
+                        print 'Failure in adding guard point'
+                        return False
+                    else:
+                        print 'Successfully added guard point'
+
+                    #  click close btn
+                    driver.find_element_by_xpath(d4_3_1_status_close).click()
+                    return True
+
+            ret = None
+            for i in range(3):
+                ret = check_status()
+                if ret:
+                    return True
+
+            if not ret:
+                print"[FAIL] Failed to verify gp status."
+                sys.exit()
+
+    ######################### LOCAL ADMIN ############################
+
+    def create_local_admin(self, admin="", admin_type="", password="",
+            roles=None, readonly=False):
+        try:
+            driver = self.driver
+            driver.find_element_by_xpath(administrator).click()
+            time.sleep(tout2)
+            driver.find_element_by_xpath(d3_1_new).click()
+            time.sleep(tout2)
+            driver.find_element_by_xpath(c3_1_login).clear()
+            driver.find_element_by_xpath(c3_1_login).send_keys(admin)
+            driver.find_element_by_xpath(c3_1_pass).clear()
+            driver.find_element_by_xpath(c3_1_pass).send_keys(password)
+            driver.find_element_by_xpath(c3_1_confirm_pass).clear()
+            driver.find_element_by_xpath(c3_1_confirm_pass).send_keys(password)
+            admin_ddl = driver.find_element_by_xpath(c3_1_user_type)
+            Select(admin_ddl).select_by_visible_text(admin_type)
+            time.sleep(1)
+            if readonly:
+                 driver.find_element_by_xpath(c3_1_read_only).click()
+            if roles is not None:
+                for role in roles:
+                    self.search_and_select(d3_1_1_role_col,
+                                           d3_1_1_role_sel_col,
+                                           role,
+                                           flag=2,
+                                           fixed_total_items=5)
+            driver.find_element_by_xpath(c3_1_ok_bt).click()
+            time.sleep(tout2)
+            return True
+        except Exception as msg:
+            print msg
+            return False
+
+    def enable_local_admin(self, local_admin=''):
+        """ Enable local admin
+
+            Args:
+                local_admin : name of local admin
+            Returns:
+                True/False
+        """
+        try:
+            driver = self.driver
+            self.refresh_page()
+            time.sleep(1)
+            driver.find_element_by_xpath(administrator).click()
+            time.sleep(tout2)
+            driver.find_element_by_xpath("//span[contains(text(), '%s')]/../../..//input[contains(@class, 'wicket')]"%local_admin).click()
+            driver.find_element_by_xpath(d3_1_enable).click()
+            time.sleep(tout2)
+            return True
+        except Exception as msg:
+            print msg
+            return False
+
+    def disable_local_admin(self, local_admin=''):
+        """ Disable local admin from domain
+
+            Args:
+                local_admin : name of local admin
+            Returns:
+                True/False
+        """
+        try:
+            driver = self.driver
+            self.refresh_page()
+            time.sleep(1)
+            driver.find_element_by_xpath(administrator).click()
+            time.sleep(tout2)
+            driver.find_element_by_xpath("//span[contains(text(), '%s')]/../../..//input[contains(@class, 'wicket')]"%local_admin).click()
+            driver.find_element_by_xpath(d3_1_disable).click()
+            time.sleep(tout2)
+            return True
+        except Exception as msg:
+            print msg
+            return False
+
+    def delete_local_admin(self, admin=""):
+        try:
+            driver = self.driver
+            driver.find_element_by_xpath(administrator).click()
+            time.sleep(tout2)
+            driver.find_element_by_xpath("//span[contains(text(), '%s')]/../../..//input[contains(@class, 'wicket')]"%admin).click()
+            driver.find_element_by_xpath(d3_1_del).click()
+            time.sleep(tout2)
+            alert = driver.switch_to_alert()
+            time.sleep(2)
+            alert.accept()
+            time.sleep(tout2)
+            return True
+        except Exception as msg:
+            print msg
+            return False
+
+    def create_global_admin(self, admin = "",
+                            admin_type = "", password = "",
+                            restricted = False,
+                            restricted_domain=""):
+        try:
+            driver = self.driver
+            driver.find_element_by_xpath(administrator).click()
+            time.sleep(tout2)
+            driver.find_element_by_xpath(c3_add_dom).click()
+            time.sleep(tout2)
+            driver.find_element_by_xpath(c3_1_login).clear()
+            driver.find_element_by_xpath(c3_1_login).send_keys(admin)
+            driver.find_element_by_xpath(c3_1_pass).clear()
+            driver.find_element_by_xpath(c3_1_pass).send_keys(password)
+            driver.find_element_by_xpath(c3_1_confirm_pass).clear()
+            driver.find_element_by_xpath(c3_1_confirm_pass).send_keys(password)
+            admin_ddl = driver.find_element_by_xpath(c3_1_user_type)
+            Select(admin_ddl).select_by_visible_text(admin_type)
+            time.sleep(tout2)
+            if restricted is True:
+                domain_ddl = driver.find_element_by_xpath(c3_1_restrict_domain)
+                Select(domain_ddl).select_by_visible_text(restricted_domain)
+                time.sleep(2)
+            try:
+                driver.find_element_by_xpath(c3_1_ok_bt).click()
+            except:
+                driver.find_element_by_xpath(c3_1_ok_bt).click()
+            time.sleep(tout2)
+            return True
+        except Exception as msg:
+            print msg
+            return False
+
+    def create_global_domain(self, domain_name = ""):
+        try:
+            driver = self.driver
+            self.refresh_page()
+            time.sleep(tout2)
+            driver.find_element_by_xpath(domain).click()
+            time.sleep(tout2)
+            driver.find_element_by_xpath(c2_1_add_dom).click()
+            time.sleep(4)
+            if self.is_element_present("xpath", d12_1_success_resp):
+                print "[DEBUG] %s " % driver.find_element_by_xpath(d12_1_success_resp).text
+                return False
+            elif self.is_element_present("xpath", d12_1_err_resp):
+                print "[DEBUG] %s " % driver.find_element_by_xpath(d12_1_err_resp).text
+                return False
+
+            driver.find_element_by_xpath(c2_1_1_dom_name_tb).clear()
+            driver.find_element_by_xpath(c2_1_1_dom_name_tb).send_keys(domain_name)
+            driver.find_element_by_xpath(c2_1_1_ok_bt).click()
+            time.sleep(5)
+            if self.is_element_present("xpath",d12_1_err_resp):
+                msg = driver.find_element_by_xpath(d12_1_err_resp).text
+                print "[INFO] %s" % msg
+                return False
+
+            elif self.is_element_present("xpath",d12_1_success_resp):
+                msg = driver.find_element_by_xpath(d12_1_success_resp).text
+                print "[INFO] %s" % msg
+                return True
+
+            return True
+        except Exception as e:
+            print "[ERROR] error occured in creating domain.\n%s" % e
+            return False
+
+    def assign_global_admin_to_global_domain(self, admin = "",
+                                             domain_name = ""):
+        try:
+            driver = self.driver
+            driver.find_element_by_xpath(domain).click()
+            time.sleep(tout2)
+            driver.find_element_by_xpath("//a/span[contains(text(),'%s')]"%domain_name).click()
+            time.sleep(tout2)
+            driver.find_element_by_xpath(c2_1_2_assign_dom).click()
+            time.sleep(tout2)
+            driver.find_element_by_xpath("//span[contains(text(),'%s')]/../..//input[@type='radio']"%admin).click()
+            driver.find_element_by_xpath(c2_1_2_ok_bt).click()
+            time.sleep(tout2)
+            return True
+        except Exception as msg:
+            #print msg
+            return False
+
+    def create_domain_with_given_agent_count(self, domain_name, agent_count):
+        """
+        takes agrumet as domain name and fs_agent count.
+        firest it will create domain and then add agent_count in the license tab.
+        returns true or false.
+        """
+        driver = self.driver
+        try:
+            self.refresh_page()
+            time.sleep(2)
+            if self.create_global_domain(domain_name):
+                print "[INFO] created domain %s successfully." % domain_name
+            else:
+                print"[INFO] failed to create domain it."
+                return False
+            if self.add_agent_count_to_domain(domain_name, agent_count):
+                print"[INFO] agent count added successfully."
+                return True
+            else:
+                print"[INFO] failed to add agent count."
+        except Exception as e:
+            print "[ERROR] error occoured while creating domain.\n%s" % e
+            sys.exit(1)
+        return False
+
+    def add_agent_count_to_domain(self, domain_name, agent_count):
+        """
+        select the domain to edit, go to license tab
+        there it ad agent count to fs agent column.
+        returns true or false.
+        """
+        driver = self.driver
+        try:
+            if self.search_domain_on_gui(domain_name):
+                driver.find_element_by_xpath(c2_1_dom_name % domain_name).click()
+                if not self.is_element_present("xpath", d2_2_license_tb):
+                    print "[FAIL] failed to locate license tab."
+                    return  False
+                driver.find_element_by_link_text("License").click()
+                time.sleep(2)
+                driver.find_elements_by_xpath(d2_2_term_agents)[0].send_keys(agent_count)
+                driver.find_element_by_xpath(d2_2_ok).click()
+                time.sleep(2)
+                if self.is_element_present("xpath", d2_2_success):
+                    print "[INFO] response massage ::  %s" % driver.find_element_by_xpath(d2_2_success).text
+                    return True
+                elif self.is_element_present("xpath", d2_2_resp):
+                    print "[INFO] response massage :: %s" % driver.find_element_by_xpath(d2_2_resp).text
+                    return False
+                else:
+                    return False
+            else:
+                print"[INFO] failed to locate domain name %s on domain page." % domain_name
+                return False
+        except Exception as e:
+            print "[FAIL] error occoured while adding agent count.\n%s" % e
+            return False
+
+    def login_first_time(self, admin = "", old_password = "",
+                         new_password = "", restricted=False,
+                         restricted_domain = ""):
+        try:
+            driver = self.driver
+            driver.find_element_by_xpath(login_tb).clear()
+            driver.find_element_by_xpath(login_tb).send_keys(admin)
+            driver.find_element_by_xpath(pass_tb).clear()
+            driver.find_element_by_xpath(pass_tb).send_keys(old_password)
+            if restricted:
+                driver.find_element_by_xpath(local_domain_cb).click()
+                time.sleep(1)
+                driver.find_element_by_xpath(local_domain_txt).clear()
+                driver.find_element_by_xpath(local_domain_txt).send_keys(restricted_domain)
+
+            driver.find_element_by_xpath(login_bt).click()
+            time.sleep(tout2)
+
+            driver.find_element_by_xpath(old_pass).clear()
+            driver.find_element_by_xpath(old_pass).send_keys(old_password)
+            driver.find_element_by_xpath(new_pass).clear()
+            driver.find_element_by_xpath(new_pass).send_keys(new_password)
+            driver.find_element_by_xpath(confirm_pass).clear()
+            driver.find_element_by_xpath(confirm_pass).send_keys(new_password)
+            driver.find_element_by_xpath(reset_ok_bt).click()
+            time.sleep(tout2)
+            self.refresh_page()
+            time.sleep(tout2)
+            return True
+        except Exception as msg:
+            print msg
+            return False
+
+    def login_with_this_user(self, admin=dsm_username, password=dsm_password,
+                             restricted=False, restricted_domain = ""):
+        try:
+            driver = self.driver
+            driver.find_element_by_xpath(login_tb).clear()
+            driver.find_element_by_xpath(login_tb).send_keys(admin)
+            driver.find_element_by_xpath(pass_tb).clear()
+            driver.find_element_by_xpath(pass_tb).send_keys(password)
+            if restricted is True:
+                domain_cb = driver.find_element_by_xpath(local_domain_cb)
+                domain_cb.click()
+                time.sleep(tout2)
+                driver.find_element_by_xpath(local_domain_txt).clear()
+                driver.find_element_by_xpath(local_domain_txt).send_keys(restricted_domain)
+            driver.find_element_by_xpath(login_bt).click()
+            time.sleep(tout2)
+            self.refresh_page()
+            time.sleep(tout2)
+            return True
+        except:
+            return False
+
+    def logout(self):
+        """logout
+        """
+        driver = self.driver
+        self.refresh_page()
+        time.sleep(1)
+        driver.find_element_by_xpath(logout).click()
+
+    def search_domain_on_gui(self, domain_name=""):
+        driver = self.driver
+        try:
+            self.refresh_page()
+            time.sleep(tout2)
+            driver = self.driver
+            driver.find_element_by_xpath(domain).click()
+            time.sleep(tout2)
+            driver.find_element_by_xpath(search_domain_txt).send_keys(domain_name)
+            driver.find_element_by_xpath(search_domain_go_btn).click()
+            time.sleep(2)
+            if not self.is_element_present("xpath", c2_1_dom_name % domain_name):
+                print "[INFO] unable to found domain %s." % domain_name
+                return False
+            else:
+                return True
+        except Exception as e:
+            print "[ERROr] error occoured while searching domain %s" % domain_name
+            return False
+
+    def delete_global_domain(self, domain_name=""):
+        driver = self.driver
+        try:
+            self.search_domain_on_gui(domain_name)
+            if not self.is_element_present("xpath", c2_1_dom_name % domain_name):
+                print "[INFO] domain not found for deletion."
+                return True
             driver.find_element_by_xpath(c2_1_single_dom_chkbx % domain_name).click()
             time.sleep(tout2)
             driver.find_element_by_xpath(c2_1_del_dom).click()
@@ -1876,13 +3649,53 @@
                 print msg
                 return False
 
-    def edit_agent_key(self, mode_of_creation="", key_name="", exp_date="", ktype="", desc=""):
+    def rotate_symmetric_key(self, key_name, rotation_count = 1, check_existance = True):
+        if key_name == "":
+            print "[DEBUG] Key name cannot be empty."
+            return False
+        
+        try:
+            driver = self.driver
+            self.refresh_page()
+            self.wait_till_element_available(xpath_value=d6_keys).click()
+
+            if check_existance:
+                search_tb = self.wait_till_element_available(xpath_value=d6_1_1_search_tb)
+                search_tb.clear()
+                search_tb.send_keys(key_name)
+                driver.find_element_by_xpath(d6_1_1_go_bt).click()
+                time.sleep(1)
+
+                if not self.is_element_present("xpath", d6_1_1_key_name % key_name):
+                    print "[DEBUG] Unable to found Key %s in Domain." % key_name
+                    return False
+            driver.find_element_by_xpath(d6_1_1_key_name % key_name).click()
+
+            for rotate in range(rotation_count):
+                current_rotation_count = self.wait_till_element_available(d6_1_1_1_1_key_version).text
+                print "[INFO] Current key version %s." % current_rotation_count
+                self.wait_till_element_available(d6_1_1_1_1_rotate).click()
+                self.wait_till_element_available(d6_1_1_1_1_alert_rotate_btn).click()
+                resp = self.wait_till_element_available(d6_1_2_1_info, wait_condition = "visible").text
+                if resp and (int(current_rotation_count)+1 == int(driver.find_element_by_xpath(d6_1_1_1_1_key_version).text)):
+                    print"[INFO] Key rotated successfully. \nresponse: %s" % resp
+                else:
+                    print"[INFO] Rotation failed."
+                    return False
+                    
+            self.wait_till_element_available(xpath_value=d6_1_1_1_ok).click()
+            return True
+        except Exception as msg:
+            print "[ERROR] Error occoured in key rotation.\n%s"%msg
+            return False
+
+    def edit_agent_key(self, mode_of_creation="", key_name="", exp_date="", ktype="", desc="",life_span=""):
         driver = self.driver
         if key_name == "":
-            print "key name cannot be empty."
+            print "[DEBUG] Key name cannot be empty."
             return False
         elif mode_of_creation == "":
-            print "mode_of_creation can not be empty."
+            print "[DEBUG] mode_of_creation can not be empty."
             return False
 
         try:
@@ -1896,18 +3709,23 @@
             time.sleep(1)
 
             if not self.is_element_present("xpath", d6_1_1_key_name % key_name):
-                print "[DEBUG] can not find Key %s" % key_name
+                print "[DEBUG] Can not find Key %s" % key_name
                 return False
 
             driver.find_element_by_xpath(d6_1_1_key_name % key_name).click()
             time.sleep(1)
 
             if mode_of_creation == 'symmetric':
-                driver.find_element_by_xpath(d6_1_1_1_desc).clear()
-                driver.find_element_by_xpath(d6_1_1_1_desc).send_keys(desc)
+                if desc:
+                    driver.find_element_by_xpath(d6_1_1_1_desc).clear()
+                    driver.find_element_by_xpath(d6_1_1_1_desc).send_keys(desc)
                 if exp_date != "":
                     driver.find_element_by_xpath(d6_1_1_1_expiry_date).clear()
                     driver.find_element_by_xpath(d6_1_1_1_expiry_date).send_keys(exp_date)
+                if life_span != "":
+                    lyf_span = self.wait_till_element_available(d6_1_1_1_life_span)
+                    lyf_span.clear()
+                    lyf_span.send_keys(life_span)
 
             elif mode_of_creation == 'asymmetric':
                 driver.find_element_by_xpath(d6_1_1_2_desc).clear()
@@ -1918,14 +3736,14 @@
             driver.find_element_by_xpath(d6_1_1_1_ok).click()
             time.sleep(tout2)
             if self.is_element_present("xpath", d6_1_1_1_resp):
-                print "[DEBUG] unable to modify key, %s" % driver.find_element_by_xpath(d6_1_1_1_resp).text
+                print "[DEBUG] Unable to modify key.\nresponse: %s" % driver.find_element_by_xpath(d6_1_1_1_resp).text
                 return False
             if self.is_element_present("xpath", d6_1_1_1_success):
                 resp = driver.find_element_by_xpath(d6_1_1_1_success).text
                 print "%s \nkey %s is modified successfully" % (resp, key_name)
                 return True
         except Exception as msg:
-            print "[ERROR] error occoured while modifying key.\n%s"%msg
+            print "[ERROR] Error occoured while modifying key.\n%s"%msg
             return False
 
     def delete_keys_from_key_group(self, key_list):
Index: Keys/Agent/keys/symmetric/version_history_verification.py
===================================================================
--- Keys/Agent/keys/symmetric/version_history_verification.py	(revision 68717)
+++ Keys/Agent/keys/symmetric/version_history_verification.py	(working copy)
@@ -53,7 +53,7 @@
             else:
                 print "[PASS] symmetric key is added successfully with key rotation feature, the functionality is passed."
 
-            version_count = random.randint(0,10)
+            version_count = random.randint(1,10)
             for version_number in range(version_count):
                 if self.check_key_hash_version_in_hash_history(mod, key, version_number):
                     print"[PASS] key version history is checked successfully..!!"
@@ -88,9 +88,10 @@
             mod.wait_till_element_available(xpath_value=d6_1_1_go_bt).click()
             print"[INFO] checking the version history."
             mod.wait_till_element_available(xpath_value= key_name, by_value=By.LINK_TEXT, wait_condition = "visible").click()
-            current_hash = mod.wait_till_element_available(xpath_value=d6_1_1_1_1_key_hash).text
+            current_hash = mod.wait_till_element_available(xpath_value=d6_1_1_1_1_key_hash, wait_condition = "visible").text
             print"[DEBUG] current key hash %s" % current_hash
-            mod.wait_till_element_available(xpath_value="Versions", by_value=By.LINK_TEXT).click()
+            
+            mod.wait_till_element_available(xpath_value="Versions", by_value=By.LINK_TEXT, wait_condition = "visible").click()
             hash_in_version_history =  mod.wait_till_element_available(
                 xpath_value=(d6_1_1_2_1_hash_for_version % version_number),
                 wait_condition = "visible").text
